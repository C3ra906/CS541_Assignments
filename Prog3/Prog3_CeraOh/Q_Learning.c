//Cera Oh. Fall 2021 CS541 AI.
//Prog3. Q-Learning
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <sys/time.h>
#include <math.h>

typedef struct agent{//Represents agent with five sensors, Current, N, S, E, W. 0 = empty, 1 = can, -1 = wall.
 int Current;
 int North;
 int South;
 int East;
 int West;
 float reward;//Variable to keep track of total reward points obtained
 float current_r;//Current reward received at given state
 int row;//Row Robby is in for tracking purposes
 int col;//Column Robby is in for tracking purposes
}Robot;

Robot move_N(Robot Robby)//Moves Robby North
{
    if (Robby.North == -1)//Wall
    {
        Robby.reward = Robby.reward - 5;
        Robby.current_r = -5;
        printf("Robby ran into a North wall and bounced back to [%d][%d] \n", Robby.row, Robby.col);
    }
    else if (Robby.North == 0 || Robby.North == 1) //No wall
    {
        Robby.row = Robby.row - 1;
        Robby.current_r = 0;
        printf("Robby moved North to [%d][%d] \n", Robby.row, Robby.col);
    }
    else
    {
        printf("Error moving N :( \n");
    }
    return Robby;
}

Robot move_S(Robot Robby)//Moves Robby South
{
    if (Robby.South == -1)//Wall
    {
        Robby.reward = Robby.reward -5;
        Robby.current_r = -5;
        printf("Robby ran into a South wall and bounced back to [%d][%d] \n", Robby.row, Robby.col);
    }
    else if (Robby.South == 0 || Robby.South == 1) //No wall
    {
        Robby.row = Robby.row + 1;
        Robby.current_r = 0;
        printf("Robby moved South to [%d][%d] \n", Robby.row, Robby.col);
    }
    else
    {
        printf("Error moving S :( \n");
    }
    return Robby;
}

Robot move_W(Robot Robby)//Moves Robby West
{
    if (Robby.West == -1)//Wall
    {
        Robby.reward = Robby.reward -5;
        Robby.current_r = -5;
        printf("Robby ran into a West wall and bounced back to [%d][%d] \n", Robby.row, Robby.col);
    }
    else if (Robby.West == 0 || Robby.West == 1) //No wall
    {
        Robby.col = Robby.col - 1;
        Robby.current_r = 0;
        printf("Robby moved West to [%d][%d] \n", Robby.row, Robby.col);
    }
    else
    {
        printf("Error moving W :( \n");
    }
    return Robby;
}

Robot move_E(Robot Robby)//Moves Robby East
{
    if (Robby.East == -1)//Wall
    {
        Robby.reward = Robby.reward -5;
        Robby.current_r = -5;
        printf("Robby ran into a East wall and bounced back to [%d][%d] \n", Robby.row, Robby.col);
    }
    else if (Robby.East == 0 || Robby.East == 1) //No wall
    {
        Robby.col = Robby.col + 1;
        Robby.current_r = 0;
        printf("Robby moved East to [%d][%d] \n", Robby.row, Robby.col);
    }
    else
    {
        printf("Error moving E :( \n");
    }
    return Robby;
}

Robot pick_up(Robot Robby, int board[10][10])//Makes Robby pick up
{
    if (board[Robby.row][Robby.col] == 1)//There's a can
    {
        Robby.reward = Robby.reward + 10;
        Robby.current_r = 10;
        board[Robby.row][Robby.col] = 0;
        printf("Robby picked up a can :) \n");
    }
    else if (board[Robby.row][Robby.col] == 0)//No can
    {
        Robby.reward = Robby.reward - 1;
        Robby.current_r = -1;
        printf("Robby attempted to pick up a can...but there was nothing :( \n");
    }
    else
    {
        printf("Error picking up can :( \n");
    }
    return Robby;
}

int board_ini (int num)//Returns whether to place a can or not for given square
{
    int chosen;//Number generated by rand()
    int seed = 0;
    int size = 2;//Max range of numbers rand() will pick from for can placement.
    struct timeval seeder;

    gettimeofday (&seeder, NULL);
    seed = seeder.tv_usec + num;
    srand(seed);
    chosen = rand() % size;

   return chosen;
}

int* robby_ini (int* position)//Returns initial row and column placement for Robby
{
    int robby_i;//row position for Robby
    int robby_j;//column position for Robby
    int seed = 0;
    int r_size = 10;//Max range of numbers rand() will pick from for Robby's row/col position
    struct timeval seeder;

    gettimeofday (&seeder, NULL);
    seed = seeder.tv_usec;
    srand(seed + 4);
    robby_i = rand() % r_size;

    srand(seed + 15);//seeds rand()
    robby_j = rand() % r_size;

    position[0] = robby_i;
    position[1] = robby_j;

    return position;
}

Robot Update_Sensors (Robot Robby, int board[10][10])//Updates sensors and reward info for Robby
{                                                    // 1 = can, 0 = empty, -1 = wall
//Update Current
    if (board[Robby.row][Robby.col] == 1)
    {
        Robby.Current = 1;//There is a can at current location
    }
    else if (board[Robby.row][Robby.col] == 0)
    {
        Robby.Current = 0;//No can at current location
    }
//Update North Sensor
    if ((Robby.row - 1) >= 0 && (Robby.row - 1) <= 9)//valid value for N: between 0 and 9
    {
        if (board[Robby.row - 1][Robby.col] == 1)
        {
            Robby.North = 1;//There is a can at N
        }
        else if (board[Robby.row - 1][Robby.col] == 0)
        {
        Robby.North = 0;//No can at N
        }
    }
    else
    {
        Robby.North = -1;//Wall at N
    }
//Update South Sensor
    if ((Robby.row + 1) >= 0 && (Robby.row + 1) <= 9)//valid value for S: between 0 and 9
    {
        if (board[Robby.row + 1][Robby.col] == 1)
        {
            Robby.South = 1;//Can at S
        }
        else if (board[Robby.row + 1][Robby.col] == 0)
        {
        Robby.South = 0;//No can at S
        }
    }
    else
    {
        Robby.South = -1;//Wall at S
    }
//Update West Sensor
    if ((Robby.col - 1) >= 0 && (Robby.col - 1) <= 9)//valid value for W: between 0 and 9
    {
        if (board[Robby.row][Robby.col - 1] == 1)
        {
            Robby.West = 1;//Can at W
        }
        else if (board[Robby.row][Robby.col - 1] == 0)
        {
        Robby.West = 0;//No can at W
        }
    }
    else
    {
        Robby.West = -1;//Wall at W
    }
//Update East Sensor
    if ((Robby.col + 1) >= 0 && (Robby.col + 1) <= 9)//valid value for E: between 0 and 9
    {
        if (board[Robby.row][Robby.col + 1] == 1)
        {
            Robby.East = 1;//Can at E
        }
        else if (board[Robby.row][Robby.col + 1] == 0)
        {
        Robby.East = 0;//No can at E
        }
    }
    else
    {
        Robby.East = -1;//Wall at E
    }

    return Robby;
}

void print_board(int board[10][10], Robot Robby)//prints 10x10 board with cans and Robby
{
    printf(" -----------------------------------------\n");
    for (int i = 0; i < 10; i++)
    {
        printf("%d|", i);
        for (int j = 0; j < 10; j++)
        {
            if (board[i][j] == 1 && (Robby.row != i || Robby.col != j))
            {
                printf(" c |");//can
            }
            else if (board[i][j] == 1 && (Robby.row == i && Robby.col == j))
            {
                printf(" Rc|");//Robby and can
            }
            else if (board[i][j] == 0 && (Robby.row == i && Robby.col == j))
            {
                printf(" R |");//Robby
            }
            else
            {
                printf("   |");
            }
        }
        printf("\n");
        printf(" -----------------------------------------\n");
    }
        printf("   0   1   2   3   4   5   6   7   8   9  \n");
}

void print_Q(float matrix[3][3][3][3][3][5])//prints Q_Matrix. For the sensors: -1 = Wall, 1 = can, 0 = no can, no wall
{
    int counter = 0;
    int k = 0;
    int l = 0;
    int c = 0;
    int r = 0;
    printf("Printing Q-Table: \n");
    printf("  [C][N][S][W][E] |\tMove North|\tMove South|\tMove West |\tMove East |\tPick Up   \n");
    printf("---------------------------------------------------------------------------------------------------\n");

    for (int c = 0; c < 3; c++)//Current Sensor
    {
        for (int n = 0; n < 3; n++)//N sensor
        {
            for (int s = 0; s < 3; s++)//S sensor
            {
                for (int w = 0; w < 3; w++)//W sensor
                {
                    for (int e = 0; e < 3; e++)//E sensor
                    {
                        printf("[%d][%d][%d][%d][%d]", c-1, n-1, s-1, w-1, e-1);
                        for (int a = 0; a < 5; a++)//actions
                        {
                            printf("|\t%f ", matrix[c][n][s][w][e][a]);
                        }
                        printf("|\n");
                        printf("--------------------------------------------------------------------------------------------------\n");
                    }
                }
            }
        }
    }
}

void print_Robby(Robot Robby)//Prints current stats of Robby
{
    printf("Robby's Current Stats: \n");
    printf("Robby is at [%d][%d] \n", Robby.row,Robby.col);
    if (Robby.Current == 1)
    {
        printf("Current: Can \n");
    }
    else if (Robby.Current == 0)
    {
        printf("Current: Empty \n");
    }
    else
    {
        printf("Current Sensor failed :(\n");
    }

    if (Robby.North == 1)
    {
        printf("North: Can \n");
    }
    else if (Robby.North == 0)
    {
        printf("North: Empty \n");
    }
    else if (Robby.North == -1)
    {
        printf("North: Wall \n");
    }
    else
    {
        printf("North Sensor failed :(\n");
    }

    if (Robby.South == 1)
    {
        printf("South: Can \n");
    }
    else if (Robby.South == 0)
    {
        printf("South: Empty \n");
    }
    else if (Robby.South == -1)
    {
        printf("South: Wall \n");
    }
    else
    {
        printf("South Sensor failed :(\n");
    }

    if (Robby.West == 1)
    {
        printf("West: Can \n");
    }
    else if (Robby.West == 0)
    {
        printf("West: Empty \n");
    }
    else if (Robby.West == -1)
    {
        printf("West: Wall \n");
    }
    else
    {
        printf("West Sensor failed :(\n");
    }

    if (Robby.East == 1)
    {
        printf("East: Can \n");
    }
    else if (Robby.East == 0)
    {
        printf("East: Empty \n");
    }
    else if (Robby.East == -1)
    {
        printf("East: Wall \n");
    }
    else
    {
        printf("East Sensor failed :(\n");
    }

    printf("Total Reward: %f \n", Robby.reward);
    printf("\n");
}

void Q_Learning (float matrix[3][3][3][3][3][5], float reward_plot[50])//Q-Learning for Robby
{
   int N = 5000;//Number of episodes
   int M = 200;//Number of steps
   float alpha = 0.2;//Learning rate
   float gamma = 0.9;//Discount rate
   int epsilon = 100;//100/1000 = 0.1 for epsilon greedy action selection

   int l_board [10][10];//Creates 10x10 board world for Robby and cans for learning
   Robot Robby;//Robby created for learning

 //variables for looping and counting
   int counter = 0;
   int N_counter = 1;
   int M_loop = 0;
   int d_epsilon = 1;

 //variables for holding values
   int* position;
   int m = 0;
   float curr_reward = 0.0;
   float max_action = 0.0;
   int max_act_index = 0;
   int currentC;
   int currentN;
   int currentS;
   int currentW;
   int currentE;

 //for rand() generator
   struct timeval seeder;
   int seed = 0;
   int num = 10;
   int can;//Number generated by rand() to determine whether there should be a can on a grid
   int prob;//Probability for rand()
   int chosen;//Number generated by rand() as action to perform
   int act = 0;//For when max values are the same

   position = malloc(2*sizeof(int));

   while (N > 0)//Loops N episodes
   {
       printf("Starting Learning episode %d: \n", N_counter);
       for (int i = 0; i < 10; i++)//initializes the board with cans
       {
           for (int j = 0; j < 10; j++)
           {
                can = board_ini(num);
                num++;
                if (can == 1)
                {
                    l_board[i][j] = 1;
                }
                else
                {
                    l_board[i][j] = 0;
                }
            }
        }

        position = robby_ini(position);//initializes Robby by placing him on a random square
        Robby.row = position[0];
        Robby.col = position[1];
        Robby = Update_Sensors(Robby, l_board);//initializes Robby's sensors
        Robby.reward = 0.0;//initializes reward to 0
        Robby.current_r = 0.0;//initializes current reward to 0

        if (d_epsilon % 50 == 0 && epsilon != 0)//Lowers epsilon by 0.01 every 50 epoch until epsilon is 0.
        {
            epsilon = epsilon - 5;
        }

        while (M_loop < M)//Loops M steps
        {
            printf("\n");
            printf("Learning Episode %d Step %d: \n", N_counter, M_loop +1);
            print_board(l_board, Robby);//Prints 10x10 board status
            print_Robby(Robby);//Prints current status of Robby

            //Store Robby's current sensory info
            currentC = Robby.Current + 1;
            currentN = Robby.North + 1;
            currentS = Robby.South + 1;
            currentW = Robby.West + 1;
            currentE = Robby.East + 1;

            for (int a = 0; a < 5; a++)//Find maxQ(s, a)
            {
                if (matrix[currentC][currentN][currentS][currentW][currentE][a] > max_action)
                {
                    max_action = matrix[currentC][currentN][currentS][currentW][currentE][a];
                    max_act_index = a;
                }
                else if (max_action != 0.0 && matrix[currentC][currentN][currentS][currentW][currentE][a] == max_action)//if there's at least two same max values
                {
                   gettimeofday (&seeder, NULL);
                   seed = seeder.tv_usec + num + 4;
                   srand(seed);
                   act = rand() % 2;
                   if (act == 0)
                   {
                       max_act_index = a;
                   }
                   num++;
                }
            }

            gettimeofday (&seeder, NULL);
            seed = seeder.tv_usec + num + 10;
            srand(seed);
            prob = rand() % 1000;

            if (prob < epsilon || max_action == 0.0)//Act random
            {
                 printf("Robby decided to act randomly: \n");
                 gettimeofday (&seeder, NULL);
                 seed = seeder.tv_usec + num + 11;
                 srand(seed);
                 chosen = rand() % 5;

                 if(chosen == 0)//Move N
                 {
                     Robby = move_N(Robby);//take action: move North
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors

                     for (int a = 0; a < 5; a++)//Find maxQ(s', a')
                     {
                         if (matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a] > max_action)
                         {
                              max_action = matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a];
                         }
                     }
                     matrix[currentC][currentN][currentS][currentW][currentE][0] = matrix[currentC][currentN][currentS][currentW][currentE][0] + alpha*(Robby.current_r + gamma*max_action - matrix[currentC][currentN][currentS][currentW][currentE][0]);
                  }
                  else if(chosen == 1)//Move S
                  {
                     Robby = move_S(Robby);//take action: move South
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors

                     for (int a = 0; a < 5; a++)//Find maxQ(s', a')
                     {
                         if (matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a] > max_action)
                         {
                              max_action = matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a];
                         }
                     }
                     matrix[currentC][currentN][currentS][currentW][currentE][1] = matrix[currentC][currentN][currentS][currentW][currentE][1] + alpha*(Robby.current_r + gamma*max_action - matrix[currentC][currentN][currentS][currentW][currentE][1]);
                  }
                  else if(chosen == 2)//Move W
                  {
                     Robby = move_W(Robby);//take action: move West
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors

                     for (int a = 0; a < 5; a++)//Find maxQ(s', a')
                     {
                         if (matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a] > max_action)
                         {
                              max_action = matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a];
                         }
                     }
                      matrix[currentC][currentN][currentS][currentW][currentE][2] = matrix[currentC][currentN][currentS][currentW][currentE][2] + alpha*(Robby.current_r + gamma*max_action - matrix[currentC][currentN][currentS][currentW][currentE][2]);
                  }
                  else if(chosen == 3)//Move E
                  {
                     Robby = move_E(Robby);//take action: move East
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors

                     for (int a = 0; a < 5; a++)//Find maxQ(s', a')
                     {
                         if (matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a] > max_action)
                         {
                              max_action = matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a];
                         }
                     }
                     matrix[currentC][currentN][currentS][currentW][currentE][3] = matrix[currentC][currentN][currentS][currentW][currentE][3] + alpha*(Robby.current_r + gamma*max_action - matrix[currentC][currentN][currentS][currentW][currentE][3]);
                  }
                  else if(chosen == 4)//Pick up
                  {
                     Robby = pick_up(Robby, l_board);//take action: pick up
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors

                     for (int a = 0; a < 5; a++)//Find maxQ(s', a')
                     {
                         if (matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a] > max_action)
                         {
                              max_action = matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a];
                         }
                     }
                     matrix[currentC][currentN][currentS][currentW][currentE][4] = matrix[currentC][currentN][currentS][currentW][currentE][4] + alpha*(Robby.current_r + gamma*max_action - matrix[currentC][currentN][currentS][currentW][currentE][4]);
                  }
                  else
                  {
                      printf("Random move failed due to an unknown error...\n");
                  }
            }
            else //do the max action
            {
                  if(max_act_index == 0)//Move N
                  {
                     Robby = move_N(Robby);//take action: move North
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors

                     for (int a = 0; a < 5; a++)//Find maxQ(s', a')
                     {
                         if (matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a] > max_action)
                         {
                              max_action = matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a];
                         }
                     }
                     matrix[currentC][currentN][currentS][currentW][currentE][0] = matrix[currentC][currentN][currentS][currentW][currentE][0] + alpha*(Robby.current_r + gamma*max_action - matrix[currentC][currentN][currentS][currentW][currentE][0]);
                   }
                  else if(max_act_index == 1)//Move S
                  {
                     Robby = move_S(Robby);//take action: move South
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors

                     for (int a = 0; a < 5; a++)//Find maxQ(s', a')
                     {
                         if (matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a] > max_action)
                         {
                              max_action = matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a];
                         }
                     }
                     matrix[currentC][currentN][currentS][currentW][currentE][1] = matrix[currentC][currentN][currentS][currentW][currentE][1] + alpha*(Robby.current_r + gamma*max_action - matrix[currentC][currentN][currentS][currentW][currentE][1]);
                  }
                  else if(max_act_index == 2)//Move W
                  {
                     Robby = move_W(Robby);//take action: move West
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors

                     for (int a = 0; a < 5; a++)//Find maxQ(s', a')
                     {
                         if (matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a] > max_action)
                         {
                              max_action = matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a];
                         }
                     }
                     matrix[currentC][currentN][currentS][currentW][currentE][2] = matrix[currentC][currentN][currentS][currentW][currentE][2] + alpha*(Robby.current_r + gamma*max_action - matrix[currentC][currentN][currentS][currentW][currentE][2]);
                  }
                  else if(max_act_index == 3)//Move E
                  {
                     Robby = move_E(Robby);//take action: move East
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors

                     for (int a = 0; a < 5; a++)//Find maxQ(s', a')
                     {
                         if (matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a] > max_action)
                         {
                              max_action = matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a];
                         }
                     }
                     matrix[currentC][currentN][currentS][currentW][currentE][3] = matrix[currentC][currentN][currentS][currentW][currentE][3] + alpha*(Robby.current_r + gamma*max_action - matrix[currentC][currentN][currentS][currentW][currentE][3]);
                  }
                  else if(max_act_index == 4)//Pick up
                  {
                     Robby = pick_up(Robby, l_board);//take action: pick up
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors

                     for (int a = 0; a < 5; a++)//Find maxQ(s', a')
                     {
                         if (matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a] > max_action)
                         {
                              max_action = matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a];
                         }
                     }
                     matrix[currentC][currentN][currentS][currentW][currentE][4] = matrix[currentC][currentN][currentS][currentW][currentE][4] + alpha*(Robby.current_r + gamma*max_action - matrix[currentC][currentN][currentS][currentW][currentE][4]);
                  }
                  else
                  {
                     printf("Unknown error trying to perform max action \n");
                  }
             }
             M_loop++;
             max_action = 0.0;//reset
             num = num + 100;//for rand()
        }

        if (N_counter % 100 == 0)//For plotting graph
        {
            reward_plot[counter] = Robby.reward;
            counter++;
        }

        printf("Total Reward gained on episode %d: %f \n", N_counter, Robby.reward);
        printf("\n");
        M_loop = 0;//reset
        N_counter++;
        N--;
        d_epsilon++;
    }
}

void TestAverge_TestSD(float t_r[5000], float SD[5000])//Calculates and Outputs Test Average and Test Standard Deviation
{
    float avg = 0.0;
    float calc = 0.0;
    float total_sd = 0.0;
    float avg_sd = 0.0;
    float pow = 0.0;
    float highest = 0.0;
    float lowest = 0.0;

    for (int i = 0; i < 5000; i++)
    {
        if (t_r[i] > highest)
        {
            highest = t_r[i];
        }
        avg = avg + t_r[i];
    }
    avg = avg/5000;
    lowest = avg;

    printf("Test-Average was %f \n", avg);

    for (int j = 0; j < 5000; j++)
    {
        calc = t_r[j] - avg;
        pow = powf(calc, 2);
        SD[j] = sqrtf(pow);
        total_sd = total_sd + SD[j];
        if (t_r[j] < lowest)
        {
            lowest = t_r[j];
        }
    }

    avg_sd = total_sd/5000;

    printf("Test_Standard Deviation was %f \n", avg_sd);
    printf("Highest reward was %f and lowest reward was %f \n", highest, lowest);
}

void print_TRewards(float r_p[50])//Prints out a chart of Training Rewards per 100 episodes
{
    printf("For Training Reward Plot: \n");
    for (int p = 0; p < 50; p++)
    {
        printf("Episode %d: %f    ", (p + 1)*100, r_p[p]);
        printf("\n");
    }
}

void print_Reward_SD(float t_r[5000], float SD[5000])//Prints out a chart of total rewards and standard deviation per episode of test run
{
    printf("For Test Rewards: \n");
    printf("Episode   |\tTest Reward  |\tSD          \n");
    printf("------------------------------\n");
    for (int q = 0; q < 5000; q++)
    {
        printf("%d        |\t%f    |\t%f     ", q+1, t_r[q], SD[q]);
        printf("\n");
    }
}

void Q_Test(float matrix[3][3][3][3][3][5], float reward[5000])//Runs Test with Robby
{
   int N = 5000;//Number of episodes
   int M = 200;//Number of steps
   float alpha = 0.2;//Learning rate
   float gamma = 0.9;//Discount rate
   int epsilon = 10;//0.1 for epsilon greedy action selection

   int l_board [10][10];//Creates 10x10 board world for Robby and cans for learning
   Robot Robby;//Robby created for learning

 //variables for looping and counting
   int counter = 0;
   int N_counter = 1;
   int M_loop = 0;

 //variables for holding values
   int* position;
   int m = 0;
   float curr_reward = 0.0;
   float max_action = 0.0;
   int max_act_index = 0;
   int currentC;
   int currentN;
   int currentS;
   int currentW;
   int currentE;

 //for rand() generator
   struct timeval seeder;
   int seed = 0;
   int num = 10;
   int can;//Number generated by rand() to determine whether there should be a can on a grid
   int prob;//Probability for rand()
   int chosen;//Number generated by rand() as action to perform
   int act = 0;

   position = malloc(2*sizeof(int));

   while (N > 0)//Loops N episodes
   {
       printf("Starting Test episode %d: \n", N_counter);
       for (int i = 0; i < 10; i++)//initializes the board with cans
       {
           for (int j = 0; j < 10; j++)
           {
                can = board_ini(num);
                num++;
                if (can == 1)
                {
                    l_board[i][j] = 1;
                }
                else
                {
                    l_board[i][j] = 0;
                }
            }
        }

        position = robby_ini(position);//initializes Robby by placing him on a random square
        Robby.row = position[0];
        Robby.col = position[1];
        Robby = Update_Sensors(Robby, l_board);//initializes Robby's sensors
        Robby.reward = 0.0;//initializes reward to 0
        Robby.current_r = 0.0;//initializes current reward to 0

        while (M_loop < M)//Loops M steps
        {
            printf("\n");
            printf("Test Episode %d Step %d: \n", N_counter, M_loop +1);
            //print_board(l_board, Robby);//Prints 10x10 board status
            //print_Robby(Robby);//Prints current status of Robby

            //Store Robby's current sensory info
            currentC = Robby.Current + 1;
            currentN = Robby.North + 1;
            currentS = Robby.South + 1;
            currentW = Robby.West + 1;
            currentE = Robby.East + 1;

            for (int a = 0; a < 5; a++)//Find maxQ(s, a)
            {
                if (matrix[currentC][currentN][currentS][currentW][currentE][a] > max_action)
                {
                    max_action = matrix[currentC][currentN][currentS][currentW][currentE][a];
                    max_act_index = a;
                }
                else if (max_action != 0.0 && matrix[currentC][currentN][currentS][currentW][currentE][a] == max_action)//if there's at least two same max values
                {
                    gettimeofday (&seeder, NULL);
                    seed = seeder.tv_usec + num + 4;
                    srand(seed);
                    act = rand() % 2;
                    if (act == 0)
                    {
                        max_act_index = a;
                    }
                    num++;
                }
            }

            gettimeofday (&seeder, NULL);
            seed = seeder.tv_usec + num + 10;
            srand(seed);
            prob = rand() % 100;

            if (prob < epsilon || max_action == 0.0)//Act random
            {
                 printf("Robby decided to act randomly: \n");
                 gettimeofday (&seeder, NULL);
                 seed = seeder.tv_usec + num + 11;
                 srand(seed);
                 chosen = rand() % 5;

                 if(chosen == 0)//Move N
                 {
                     Robby = move_N(Robby);//take action: move North
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors

                     for (int a = 0; a < 5; a++)//Find maxQ(s', a')
                     {
                         if (matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a] > max_action)
                         {
                              max_action = matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a];
                         }
                     }
                     matrix[currentC][currentN][currentS][currentW][currentE][0] = matrix[currentC][currentN][currentS][currentW][currentE][0] + alpha*(Robby.current_r + gamma*max_action - matrix[currentC][currentN][currentS][currentW][currentE][0]);
                  }
                  else if(chosen == 1)//Move S
                  {
                     Robby = move_S(Robby);//take action: move South
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors

                     for (int a = 0; a < 5; a++)//Find maxQ(s', a')
                     {
                         if (matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a] > max_action)
                         {
                              max_action = matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a];
                         }
                     }
                     matrix[currentC][currentN][currentS][currentW][currentE][1] = matrix[currentC][currentN][currentS][currentW][currentE][1] + alpha*(Robby.current_r + gamma*max_action - matrix[currentC][currentN][currentS][currentW][currentE][1]);
                  }
                  else if(chosen == 2)//Move W
                  {
                     Robby = move_W(Robby);//take action: move West
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors

                     for (int a = 0; a < 5; a++)//Find maxQ(s', a')
                     {
                         if (matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a] > max_action)
                         {
                              max_action = matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a];
                         }
                     }
                     matrix[currentC][currentN][currentS][currentW][currentE][2] = matrix[currentC][currentN][currentS][currentW][currentE][2] + alpha*(Robby.current_r + gamma*max_action - matrix[currentC][currentN][currentS][currentW][currentE][2]);
                  }
                  else if(chosen == 3)//Move E
                  {
                     Robby = move_E(Robby);//take action: move East
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors

                     for (int a = 0; a < 5; a++)//Find maxQ(s', a')
                     {
                         if (matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a] > max_action)
                         {
                              max_action = matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a];
                         }
                     }
                     matrix[currentC][currentN][currentS][currentW][currentE][3] = matrix[currentC][currentN][currentS][currentW][currentE][3] + alpha*(Robby.current_r + gamma*max_action - matrix[currentC][currentN][currentS][currentW][currentE][3]);
                  }
                  else if(chosen == 4)//Pick up
                  {
                     Robby = pick_up(Robby, l_board);//take action: pick up
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors

                     for (int a = 0; a < 5; a++)//Find maxQ(s', a')
                     {
                         if (matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a] > max_action)
                         {
                              max_action = matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a];
                         }
                     }
                     matrix[currentC][currentN][currentS][currentW][currentE][4] = matrix[currentC][currentN][currentS][currentW][currentE][4] + alpha*(Robby.current_r + gamma*max_action - matrix[currentC][currentN][currentS][currentW][currentE][4]);
                  }
                  else
                  {
                      printf("Random move failed due to an unknown error...\n");
                  }
            }
            else //do the max action
            {
                  if(max_act_index == 0)//Move N
                  {
                     Robby = move_N(Robby);//take action: move North
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors

                     for (int a = 0; a < 5; a++)//Find maxQ(s', a')
                     {
                         if (matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a] > max_action)
                         {
                              max_action = matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a];
                         }
                     }
                     matrix[currentC][currentN][currentS][currentW][currentE][0] = matrix[currentC][currentN][currentS][currentW][currentE][0] + alpha*(Robby.current_r + gamma*max_action - matrix[currentC][currentN][currentS][currentW][currentE][0]);
                  }
                  else if(max_act_index == 1)//Move S
                  {
                     Robby = move_S(Robby);//take action: move South
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors

                     for (int a = 0; a < 5; a++)//Find maxQ(s', a')
                     {
                         if (matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a] > max_action)
                         {
                              max_action = matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a];
                         }
                     }
                     matrix[currentC][currentN][currentS][currentW][currentE][1] = matrix[currentC][currentN][currentS][currentW][currentE][1] + alpha*(Robby.current_r + gamma*max_action - matrix[currentC][currentN][currentS][currentW][currentE][1]);
                  }
                  else if(max_act_index == 2)//Move W
                  {
                     Robby = move_W(Robby);//take action: move West
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors

                     for (int a = 0; a < 5; a++)//Find maxQ(s', a')
                     {
                         if (matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a] > max_action)
                         {
                              max_action = matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a];
                         }
                     }
                     matrix[currentC][currentN][currentS][currentW][currentE][2] = matrix[currentC][currentN][currentS][currentW][currentE][2] + alpha*(Robby.current_r + gamma*max_action - matrix[currentC][currentN][currentS][currentW][currentE][2]);
                  }
                  else if(max_act_index == 3)//Move E
                  {
                     Robby = move_E(Robby);//take action: move East
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors

                     for (int a = 0; a < 5; a++)//Find maxQ(s', a')
                     {
                         if (matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a] > max_action)
                         {
                              max_action = matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a];
                         }
                     }
                     matrix[currentC][currentN][currentS][currentW][currentE][3] = matrix[currentC][currentN][currentS][currentW][currentE][3] + alpha*(Robby.current_r + gamma*max_action - matrix[currentC][currentN][currentS][currentW][currentE][3]);
                  }
                  else if(max_act_index == 4)//Pick up
                  {
                     Robby = pick_up(Robby, l_board);//take action: pick up
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors

                     for (int a = 0; a < 5; a++)//Find maxQ(s', a')
                     {
                         if (matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a] > max_action)
                         {
                              max_action = matrix[Robby.Current + 1][Robby.North + 1][Robby.South + 1][Robby.West + 1][Robby.East + 1][a];
                         }
                     }
                     matrix[currentC][currentN][currentS][currentW][currentE][4] = matrix[currentC][currentN][currentS][currentW][currentE][4] + alpha*(Robby.current_r + gamma*max_action - matrix[currentC][currentN][currentS][currentW][currentE][4]);
                  }
                  else
                  {
                     printf("Unknown error trying to perform max action \n");
                  }
             }
             M_loop++;
             max_action = 0.0;//reset
             num = num + 100;//for rand()
        }

        reward[counter] = Robby.reward;//Data collecting for Test-average and Standard dev calculation
        counter++;

        printf("Total Reward gained on episode %d: %f \n", N_counter, Robby.reward);
        printf("\n");
        M_loop = 0;//reset
        N_counter++;
        N--;
    }
}

int main ()
{
    float Q_Matrix [3][3][3][3][3][5] = {0.0};//Q-Table for Robby, initialized to 0.
    float reward_plot[50] = {0.0};
    float test_rewards[5000] = {0.0};
    float SD[5000] = {0.0};

    Q_Learning(Q_Matrix, reward_plot);//Run Q-Learning
    //print_Q(Q_Matrix);//Prints out Q-Table
    Q_Test (Q_Matrix, test_rewards);//Run Test
    //print_Q(Q_Matrix);//Prints out Q-Table

    TestAverge_TestSD(test_rewards, SD);//Outputs Test Average and Test Standard Deviation
    //print_TRewards(reward_plot);//Prints out a chart of Training Rewards per 100 episodes
    //print_Reward_SD(test_rewards, SD);//Prints out a chart of total rewards and standard deviation per episode of test run

    return (EXIT_SUCCESS);
}
