//Cera Oh. Fall 2021 CS541 AI.
//Prog2 Genetic Algorithm for 8-Queens Problem
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <sys/time.h>
#include <math.h>

typedef struct agent{//Represents agent with five sensors, Current, N, S, E, W. 0 = empty, 1 = can, -1 = wall.
 int Current;
 int North;
 int South;
 int East;
 int West;
 int reward;
 int current_r;
 int row;//Row Robby is in
 int col;//Column Robby is in
}Robot;

Robot move_N(Robot Robby)
{
    if (Robby.North == -1)//Wall
    {
        Robby.reward = Robby.reward - 5;
        Robby.current_r = -5;
        printf("Robby ran into a North wall and bounced back to [%d][%d] \n", Robby.row, Robby.col);
    }
    else if (Robby.North == 0 || Robby.North == 1) //No wall
    {
        Robby.row = Robby.row - 1;
        Robby.current_r = 0;
        printf("Robby moved North to [%d][%d] \n", Robby.row, Robby.col);
    }
    else
    {
        printf("Error moving N :( \n");
    }
    return Robby;
}

Robot move_S(Robot Robby)
{
    if (Robby.South == -1)//Wall
    {
        Robby.reward = Robby.reward -5;
        Robby.current_r = -5;
        printf("Robby ran into a South wall and bounced back to [%d][%d] \n", Robby.row, Robby.col);
    }
    else if (Robby.South == 0 || Robby.South == 1) //No wall
    {
        Robby.row = Robby.row + 1;
        Robby.current_r = 0;
        printf("Robby moved South to [%d][%d] \n", Robby.row, Robby.col);
    }
    else
    {
        printf("Error moving S :( \n");
    }
    return Robby;
}

Robot move_W(Robot Robby)
{
    if (Robby.West == -1)//Wall
    {
        Robby.reward = Robby.reward -5;
        Robby.current_r = -5;
        printf("Robby ran into a West wall and bounced back to [%d][%d] \n", Robby.row, Robby.col);
    }
    else if (Robby.West == 0 || Robby.West == 1) //No wall
    {
        Robby.col = Robby.col - 1;
        Robby.current_r = 0;
        printf("Robby moved West to [%d][%d] \n", Robby.row, Robby.col);
    }
    else
    {
        printf("Error moving W :( \n");
    }
    return Robby;
}

Robot move_E(Robot Robby)
{
    if (Robby.East == -1)//Wall
    {
        Robby.reward = Robby.reward -5;
        Robby.current_r = -5;
        printf("Robby ran into a East wall and bounced back to [%d][%d] \n", Robby.row, Robby.col);
    }
    else if (Robby.East == 0 || Robby.East == 1) //No wall
    {
        Robby.col = Robby.col + 1;
        Robby.current_r = 0;
        printf("Robby moved East to [%d][%d] \n", Robby.row, Robby.col);
    }
    else
    {
        printf("Error moving E :( \n");
    }
    return Robby;
}

Robot pick_up(Robot Robby, int board[10][10])
{
    if (board[Robby.row][Robby.col] == 1)//There's a can
    {
        Robby.reward = Robby.reward + 10;
        Robby.current_r = 10;
        board[Robby.row][Robby.col] = 0;
        printf("Robby picked up a can :) \n");
    }
    else if (board[Robby.row][Robby.col] == 0) //No can
    {
        Robby.reward = Robby.reward - 1;
        Robby.current_r = -1;
        printf("Robby attempted to pick up a can...but there was nothing :( \n");
    }
    else
    {
        printf("Error picking up can :( \n");
    }
    return Robby;
}

int board_ini (int num)
{
    int chosen;//Number generated by rand()
    int seed = 0;
    int size = 2;//Max range of numbers rand() will pick from for can placement.
    struct timeval seeder;

    gettimeofday (&seeder, NULL);
    seed = seeder.tv_usec + num;
    srand(seed);
    chosen = rand() % size;

   return chosen;
}

int* robby_ini (int* position)
{

    int robby_i;//row position for Robby
    int robby_j;//column position for Robby
    int seed = 0;
    int r_size = 10;//Max range of numbers rand() will pick from for Robby's row/col position
    struct timeval seeder;

    gettimeofday (&seeder, NULL);
    seed = seeder.tv_usec;
    srand(seed + 4);

    robby_i = rand() % r_size;

    srand(seed + 15);//seeds rand()
    robby_j = rand() % r_size;

    position[0] = robby_i;
    position[1] = robby_j;

    return position;
}

Robot Update_Sensors (Robot Robby, int board[10][10])//Updates sensors and reward info for Robby
{                                                                      // 1 = can, 0 = empty, -1 = wall
//Update Current
    if (board[Robby.row][Robby.col] == 1)
    {
        Robby.Current = 1;//There is a can at current location
    }
    else if (board[Robby.row][Robby.col] == 0)
    {
        Robby.Current = 0;//No can at current location
    }
//Update North Sensor
    if ((Robby.row - 1) >= 0 && (Robby.row - 1) <= 9)//valid value for N: between 0 and 9
    {
        if (board[Robby.row - 1][Robby.col] == 1)
        {
            Robby.North = 1;//There is a can at N
        }
        else if (board[Robby.row - 1][Robby.col] == 0)
        {
        Robby.North = 0;//No can at N
        }
    }
    else
    {
        Robby.North = -1;//Wall at N
    }
//Update South Sensor
 int South;
    if ((Robby.row + 1) >= 0 && (Robby.row + 1) <= 9)//valid value for S: between 0 and 9
    {
        if (board[Robby.row + 1][Robby.col] == 1)
        {
            Robby.South = 1;//Can at S
        }
        else if (board[Robby.row + 1][Robby.col] == 0)
        {
        Robby.South = 0;//No can at S
        }
    }
    else
    {
        Robby.South = -1;//Wall at S
    }
//Update West Sensor
    if ((Robby.col - 1) >= 0 && (Robby.col - 1) <= 9)//valid value for W: between 0 and 9
    {
        if (board[Robby.row][Robby.col - 1] == 1)
        {
            Robby.West = 1;//Can at W
        }
        else if (board[Robby.row][Robby.col - 1] == 0)
        {
        Robby.West = 0;//No can at W
        }
    }
    else
    {
        Robby.West = -1;//Wall at W
    }
//Update East Sensor
    if ((Robby.col + 1) >= 0 && (Robby.col + 1) <= 9)//valid value for E: between 0 and 9
    {
        if (board[Robby.row][Robby.col + 1] == 1)
        {
            Robby.East = 1;//Can at E
        }
        else if (board[Robby.row][Robby.col + 1] == 0)
        {
        Robby.East = 0;//No can at E
        }
    }
    else
    {
        Robby.East = -1;//Wall at E
    }

    return Robby;
}

void print_board(int board[10][10], Robot Robby)//prints 10x10 board
{
    printf(" -----------------------------------------\n");
    for (int i = 0; i < 10; i++)
    {
        printf("%d|", i);
        for (int j = 0; j < 10; j++)
        {
            if (board[i][j] == 1 && (Robby.row != i || Robby.col != j))
            {
                printf(" c |");//can
            }
            else if (board[i][j] == 1 && (Robby.row == i && Robby.col == j))
            {
                printf(" Rc|");//Robby
            }
            else if (board[i][j] == 0 && (Robby.row == i && Robby.col == j))
            {
                printf(" R |");//Robby
            }
            else
            {
                printf("   |");
            }
        }
        printf("\n");
        printf(" -----------------------------------------\n");
    }
        printf("   0   1   2   3   4   5   6   7   8   9  \n");
}

void print_Q(float matrix[100][5])//prints Q_Matrix
{
    int counter = 0;
    int k = 0;
    int l = 0;
    printf("Printing Q-Matrix: \n");
    printf(" Matrix |\tNorth    |\tSouth    |\tWest     |\tEast     |\tPick Up   \n");
    printf("-------------------------------------------------------------------------------------------\n");
    for (int i = 0; i < 100; i++)
    {
        printf(" [%d][%d] |", l, k);
        for(int j = 0; j < 5; j++)
        {

            printf("\t%f |", matrix[i][j]);
        }
        k++;
        if (k == 10)
        {
            l++;
            k = 0;
        }
        printf("\n");
        printf("-------------------------------------------------------------------------------------------\n");
    }
}

void print_Robby(Robot Robby)
{
    printf("Robby's Stats: \n");
    printf("Robby is at [%d][%d] \n", Robby.row,Robby.col);
    if (Robby.Current == 1)
    {
        printf("Current: Can \n");
    }
    else if (Robby.Current == 0)
    {
        printf("Current: Empty \n");
    }
    else
    {
        printf("Current Sensor failed :(\n");
    }

    if (Robby.North == 1)
    {
        printf("North: Can \n");
    }
    else if (Robby.North == 0)
    {
        printf("North: Empty \n");
    }
    else if (Robby.North == -1)
    {
        printf("North: Wall \n");
    }
    else
    {
        printf("North Sensor failed :(\n");
    }

    if (Robby.South == 1)
    {
        printf("South: Can \n");
    }
    else if (Robby.South == 0)
    {
        printf("South: Empty \n");
    }
    else if (Robby.South == -1)
    {
        printf("South: Wall \n");
    }
    else
    {
        printf("South Sensor failed :(\n");
    }

    if (Robby.West == 1)
    {
        printf("West: Can \n");
    }
    else if (Robby.West == 0)
    {
        printf("West: Empty \n");
    }
    else if (Robby.West == -1)
    {
        printf("West: Wall \n");
    }
    else
    {
        printf("West Sensor failed :(\n");
    }

    if (Robby.East == 1)
    {
        printf("East: Can \n");
    }
    else if (Robby.East == 0)
    {
        printf("East: Empty \n");
    }
    else if (Robby.East == -1)
    {
        printf("East: Wall \n");
    }
    else
    {
        printf("East Sensor failed :(\n");
    }

    printf("Reward: %d \n", Robby.reward);
    printf("\n");
}

void Q_Learning (float matrix[100][5], float reward_plot[50])
{
   int counter = 0;
   int N = 5000;//5000;//Number of episodes
   int N_counter = 1;
   int M = 200;//200;//Number of steps
   int M_loop = 0;
   float alpha = 0.2;
   float gamma = 0.9;
   int epsilon = 10;//0.1
   int row_calc;
   int l_board [10][10];//Creates 10x10 board world for Robby and cans for learning
   Robot Robby;//Robby created for learning
   int can;//Number generated by rand() to determine whether there should be a can on a grid
   int* position;
   int prob;//Probability for rand()
   int seed = 0;
   int chosen;//Number generated by rand() as action to perform
   int curr_reward = 0;
   float max_action = 0.0;
   int max_act_index = 0;
   struct timeval seeder;
   int num = 10;
   position = malloc(2*sizeof(int));

   while (N > 0)
   {
       printf("Starting episode %d: \n", N_counter);
       for (int i = 0; i < 10; i++)//initializes the board with cans
       {
           for (int j = 0; j < 10; j++)
           {
                can = board_ini(num);
                num++;
                if (can == 1)
                {
                    l_board[i][j] = 1;
                }
                else
                {
                    l_board[i][j] = 0;
                }
            }
        }
        position = robby_ini(position);
        Robby.row = position[0];
        Robby.col = position[1];
        Robby = Update_Sensors(Robby, l_board);//initializes Robby's sensors
        Robby.reward = 0;//initializes reward
        Robby.current_r = 0;//initializes current reward

       while (M_loop < M)
       {
           printf("\n");
           printf("Episode %d Step %d: \n", N_counter, M_loop +1);
           print_board(l_board, Robby);
           print_Robby(Robby);//Current state of Robby
           row_calc = (Robby.row * 10) + Robby.col;

           for (int k = 0; k < 5; k++)//find maxQ(s', a')
           {
               if (matrix[row_calc][k] > max_action)
               {
                   max_action = matrix[row_calc][k];
                   max_act_index = k;
               }
           }

           gettimeofday (&seeder, NULL);
           seed = seeder.tv_usec + 10;
           srand(seed);
           prob = rand() % 100;

           if (M_loop % 50 == 0 && epsilon != 0)
           {
               epsilon = epsilon - 1;
           }

           if (prob >= epsilon)//do the max action
           {
               if (max_action != 0.0)
               {
                   if (Robby.Current == 1)//Pick up can at current
                   {
                      Robby = pick_up(Robby, l_board);//Performs action
                      Robby = Update_Sensors(Robby, l_board);//Update Sensors
                      printf("Current Q value: %f \n", matrix[row_calc][4]);
                      matrix[row_calc][4] = matrix[row_calc][4] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][4]);
                      printf("Updated Q value: %f \n", matrix[row_calc][4]);
                   }
                   else
                   {
                       if(max_act_index == 0 && Robby.North != -1)//Max Q value moving N
                       {
                          if (Robby.North == 1)//There is can at N
                          {
                              Robby = move_N(Robby);//Performs action
                              Robby = Update_Sensors(Robby, l_board);//Update Sensors
                              printf("Current Q value: %f \n", matrix[row_calc][0]);
                              matrix[row_calc][0] = matrix[row_calc][0] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0]);
                              printf("Updated Q value: %f \n", matrix[row_calc][0]);
                          }
                          else if (Robby.North != 1)//There is no can at N
                          {
                              if (Robby.South == 1 && matrix[row_calc][1] >= matrix[row_calc][2] && matrix[row_calc][1] >= matrix[row_calc][3])
                              {
                                 Robby = move_S(Robby);//Performs action
                                 Robby = Update_Sensors(Robby, l_board);//Update Sensors
                                 printf("Current Q value: %f \n", matrix[row_calc][1]);
                                 matrix[row_calc][1] = matrix[row_calc][1] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1]);
                                 printf("Updated Q value: %f \n", matrix[row_calc][1]);
                              }
                              else if (Robby.West == 1 && matrix[row_calc][2] >= matrix[row_calc][1] && matrix[row_calc][2] >= matrix[row_calc][3])
                              {
                                 Robby = move_W(Robby);//Performs action
                                 Robby = Update_Sensors(Robby, l_board);//Update Sensors
                                 printf("Current Q value: %f \n", matrix[row_calc][2]);
                                 matrix[row_calc][2] = matrix[row_calc][2] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][2]);
                                 printf("Updated Q value: %f \n", matrix[row_calc][2]);
                              }
                              else if (Robby.East == 1 && matrix[row_calc][3] >= matrix[row_calc][2] && matrix[row_calc][3] >= matrix[row_calc][1])
                              {
                                 Robby = move_E(Robby);//Performs action
                                 Robby = Update_Sensors(Robby, l_board);//Update Sensors
                                 printf("Current Q value: %f \n", matrix[row_calc][3]);
                                 matrix[row_calc][3] = matrix[row_calc][3] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][3]);
                                 printf("Updated Q value: %f \n", matrix[row_calc][3]);
                              }
                          }
                       }
                   }

                   else if (max_act_index == 1 && Robby.South == 1)//Max Q value moving S, no can at current, S has a can
                   {
                        Robby = move_S(Robby);//Performs action
                        Robby = Update_Sensors(Robby, l_board);//Update Sensors
                        printf("Current Q value: %f \n", matrix[row_calc][1]);
                        matrix[row_calc][1] = matrix[row_calc][1] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1]);
                        printf("Updated Q value: %f \n", matrix[row_calc][1]);
                   }
                   else if (max_act_index == 2 && Robby.West == 1)//Max Q value moving W, no can at current, W has a can
                   {
                        Robby = move_W(Robby);//Performs action
                        Robby = Update_Sensors(Robby, l_board);//Update Sensors
                        printf("Current Q value: %f \n", matrix[row_calc][2]);
                        matrix[row_calc][2] = matrix[row_calc][2] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][2]);
                        printf("Updated Q value: %f \n", matrix[row_calc][2]);
                   }
                   else if (max_act_index == 3 && Robby.Current != 1 && Robby.East == 1)//Max Q value moving E, no can at current, E has a can
                   {
                       Robby = move_W(Robby);//Performs action
                       Robby = Update_Sensors(Robby, l_board);//Update Sensors
                       printf("Current Q value: %f \n", matrix[row_calc][3]);
                       matrix[row_calc][3] = matrix[row_calc][3] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][3]);
                       printf("Updated Q value: %f \n", matrix[row_calc][3]);
                   }
                   else if (max_act_index == 4 && Robby.Current == 1)//Pick up can at current
                   {
                      Robby = pick_up(Robby, l_board);//Performs action
                      Robby = Update_Sensors(Robby, l_board);//Update Sensors
                      printf("Current Q value: %f \n", matrix[row_calc][4]);
                      matrix[row_calc][4] = matrix[row_calc][4] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][4]);
                      printf("Updated Q value: %f \n", matrix[row_calc][4]);
                   }
                   else
                   {
                       printf("Error choosing a random move \n");
                   }
                   }
               }
               else if(Robby.Current == 1)//Can
               {
                   Robby = pick_up(Robby, l_board);//Performs action
                   Robby = Update_Sensors(Robby, l_board);//Update Sensors
                   printf("Current Q value: %f \n", matrix[row_calc][4]);
                   matrix[row_calc][4] = matrix[row_calc][4] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][4]);
                   printf("Updated Q value: %f \n", matrix[row_calc][4]);
               }
               else if(Robby.North == 1)
               {
                   Robby = move_N(Robby);//Performs action
                   Robby = Update_Sensors(Robby, l_board);//Update Sensors
                   printf("Current Q value: %f \n", matrix[row_calc][0]);
                   matrix[row_calc][0] = matrix[row_calc][0] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0]);
                   printf("Updated Q value: %f \n", matrix[row_calc][0]);
               }
               else if(Robby.South == 1)
               {
                   Robby = move_S(Robby);//Performs action
                   Robby = Update_Sensors(Robby, l_board);//Update Sensors
                   printf("Current Q value: %f \n", matrix[row_calc][1]);
                   matrix[row_calc][1] = matrix[row_calc][1] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1]);
                   printf("Updated Q value: %f \n", matrix[row_calc][1]);
               }
               else if(Robby.West == 1)
               {
                   Robby = move_W(Robby);//Performs action
                   Robby = Update_Sensors(Robby, l_board);//Update Sensors
                   printf("Current Q value: %f \n", matrix[row_calc][2]);
                   matrix[row_calc][2] = matrix[row_calc][2] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][2]);
                   printf("Updated Q value: %f \n", matrix[row_calc][2]);
               }
               else if(Robby.East == 1)
               {
                   Robby = move_E(Robby);//Performs action
                   Robby = Update_Sensors(Robby, l_board);//Update Sensors
                   printf("Current Q value: %f \n", matrix[row_calc][3]);
                   matrix[row_calc][3] = matrix[row_calc][3] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][3]);
                   printf("Updated Q value: %f \n", matrix[row_calc][3]);
               }
               else if(Robby.North == 0)
               {
                   Robby = move_N(Robby);//Performs action
                   Robby = Update_Sensors(Robby, l_board);//Update Sensors
                   printf("Current Q value: %f \n", matrix[row_calc][0]);
                   matrix[row_calc][0] = matrix[row_calc][0] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0]);
                   printf("Updated Q value: %f \n", matrix[row_calc][0]);
               }
               else if(Robby.South == 0)
               {
                   Robby = move_S(Robby);//Performs action
                   Robby = Update_Sensors(Robby, l_board);//Update Sensors
                   printf("Current Q value: %f \n", matrix[row_calc][1]);
                   matrix[row_calc][1] = matrix[row_calc][1] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1]);
                   printf("Updated Q value: %f \n", matrix[row_calc][1]);
               }
               else if(Robby.West == 0)
               {
                   Robby = move_W(Robby);//Performs action
                   Robby = Update_Sensors(Robby, l_board);//Update Sensors
                   printf("Current Q value: %f \n", matrix[row_calc][2]);
                   matrix[row_calc][2] = matrix[row_calc][2] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][2]);
                   printf("Updated Q value: %f \n", matrix[row_calc][2]);
               }
               else if(Robby.East == 0)
               {
                   Robby = move_E(Robby);//Performs action
                   Robby = Update_Sensors(Robby, l_board);//Update Sensors
                   printf("Current Q value: %f \n", matrix[row_calc][3]);
                   matrix[row_calc][3] = matrix[row_calc][3] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][3]);
                   printf("Updated Q value: %f \n", matrix[row_calc][3]);
               }
           }
           else
           {
               printf("Robby decided to act randomly: \n");
               seed = seeder.tv_usec + num + 11;
               srand(seed);
               chosen = rand() % 5;
               if(chosen == 0)//Move N
               {
                    Robby = move_N(Robby);//Performs action
                    Robby = Update_Sensors(Robby, l_board);//Update Sensors
                    printf("Current Q value: %f \n", matrix[row_calc][0]);
                    matrix[row_calc][0] = matrix[row_calc][0] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0]);
                    printf("Updated Q value: %f \n", matrix[row_calc][0]);
               }
               else if (chosen == 1)//Move S
               {
                    Robby = move_S(Robby);//Performs action
                    Robby = Update_Sensors(Robby, l_board);//Update Sensors
                    printf("Current Q value: %f \n", matrix[row_calc][1]);
                    matrix[row_calc][1] = matrix[row_calc][1] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1]);
                    printf("Updated Q value: %f \n", matrix[row_calc][1]);
               }
               else if (chosen == 2)//Move W
               {
                    Robby = move_W(Robby);//Performs action
                    Robby = Update_Sensors(Robby, l_board);//Update Sensors
                    printf("Current Q value: %f \n", matrix[row_calc][2]);
                    matrix[row_calc][2] = matrix[row_calc][2] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][2]);
                    printf("Updated Q value: %f \n", matrix[row_calc][2]);
               }
               else if (chosen == 3)//Move E
               {
                    Robby = move_W(Robby);//Performs action
                    Robby = Update_Sensors(Robby, l_board);//Update Sensors
                    printf("Current Q value: %f \n", matrix[row_calc][3]);
                    matrix[row_calc][3] = matrix[row_calc][3] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][3]);
                    printf("Updated Q value: %f \n", matrix[row_calc][3]);
               }
               else if (chosen == 4)//Pick up can
               {
                   Robby = pick_up(Robby, l_board);//Performs action
                   Robby = Update_Sensors(Robby, l_board);//Update Sensors
                   printf("Current Q value: %f \n", matrix[row_calc][4]);
                   matrix[row_calc][4] = matrix[row_calc][4] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][4]);
                   printf("Updated Q value: %f \n", matrix[row_calc][4]);
               }
               else
               {
                   printf("Error choosing a random move \n");
               }
           }
          M_loop++;
       }
       epsilon = 10;
       reward_plot[counter] = Robby.reward;
       counter++;
       printf("Total Reward gained on episode %d: %d \n", N_counter, Robby.reward);
       printf("\n");
       N_counter++;
       N--;
       M_loop = 0;
   }
}

float Standard_Dev (float t_r[5000], float SD[5000])
{
    float avg = 0.0;
    float calc = 0.0;

    for (int i = 0; i < 5000; i++)
    {
        avg = avg + t_r[i];
    }
    avg = avg/5000;

    for (int j = 0; j < 5000; j++)
    {
        calc = t_r[j] - avg;
        SD[j] = powf(calc, 2);
    }

    return avg;
}


void Q_Test (float matrix[100][5], float reward[5000])
{
   int counter = 0;
   int N = 5000;//5000;//Number of episodes
   int N_counter = 1;
   int M = 200;//200;//Number of steps
   int M_loop = 0;
   float alpha = 0.2;
   float gamma = 0.9;
   int epsilon = 10;//0.1
   int row_calc;
   int l_board [10][10];//Creates 10x10 board world for Robby and cans for learning
   Robot Robby;//Robby created for learning
   int can;//Number generated by rand() to determine whether there should be a can on a grid
   int* position;
   int prob;//Probability for rand()
   int seed = 0;
   int chosen;//Number generated by rand() as action to perform
   int curr_reward = 0;
   float max_action = 0.0;
   int max_act_index = 0;
   struct timeval seeder;
   int num = 10;
   position = malloc(2*sizeof(int));

   while (N > 0)
   {
       printf("Starting episode %d: \n", N_counter);
       for (int i = 0; i < 10; i++)//initializes the board with cans
       {
           for (int j = 0; j < 10; j++)
           {
                can = board_ini(num);
                num++;
                if (can == 1)
                {
                    l_board[i][j] = 1;
                }
                else
                {
                    l_board[i][j] = 0;
                }
            }
        }
        position = robby_ini(position);
        Robby.row = position[0];
        Robby.col = position[1];
        Robby = Update_Sensors(Robby, l_board);//initializes Robby's sensors
        Robby.reward = 0;//initializes reward
        Robby.current_r = 0;//initializes current reward


       while (M_loop < M)
       {
           printf("\n");
           printf("Episode %d Step %d: \n", N_counter, M_loop +1);
           print_board(l_board, Robby);
           print_Robby(Robby);//Current state of Robby
           row_calc = (Robby.row * 10) + Robby.col;

           for (int k = 0; k < 5; k++)//find maxQ(s', a')
           {
               if (matrix[row_calc][k] > max_action)
               {
                   max_action = matrix[row_calc][k];
                   max_act_index = k;
               }
           }

           gettimeofday (&seeder, NULL);
           seed = seeder.tv_usec + num;
           srand(seed);
           prob = rand() % 100;
           num++;
           if (prob >= epsilon)//do the max action
           {
               if (max_action != 0)
               {
                   if(max_act_index == 0)//Move N
                   {
                        Robby = move_N(Robby);//Performs action
                        Robby = Update_Sensors(Robby, l_board);//Update Sensors
                        printf("Current Q value: %f \n", matrix[row_calc][0]);
                        matrix[row_calc][0] = matrix[row_calc][0] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0]);
                        printf("Updated Q value: %f \n", matrix[row_calc][0]);
                   }
                   else if (max_act_index == 1)//Move S
                   {
                        Robby = move_S(Robby);//Performs action
                        Robby = Update_Sensors(Robby, l_board);//Update Sensors
                        printf("Current Q value: %f \n", matrix[row_calc][1]);
                        matrix[row_calc][1] = matrix[row_calc][1] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1]);
                        printf("Updated Q value: %f \n", matrix[row_calc][1]);
                   }
                   else if (max_act_index == 2)//Move W
                   {
                        Robby = move_W(Robby);//Performs action
                        Robby = Update_Sensors(Robby, l_board);//Update Sensors
                        printf("Current Q value: %f \n", matrix[row_calc][2]);
                        matrix[row_calc][2] = matrix[row_calc][2] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][2]);
                        printf("Updated Q value: %f \n", matrix[row_calc][2]);
                   }
                   else if (max_act_index == 3)//Move E
                   {
                       Robby = move_W(Robby);//Performs action
                       Robby = Update_Sensors(Robby, l_board);//Update Sensors
                       printf("Current Q value: %f \n", matrix[row_calc][3]);
                       matrix[row_calc][0] = matrix[row_calc][3] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][3]);
                       printf("Updated Q value: %f \n", matrix[row_calc][3]);
                   }
                   else if (max_act_index == 4)//Pick up can
                   {
                      Robby = pick_up(Robby, l_board);//Performs action
                      Robby = Update_Sensors(Robby, l_board);//Update Sensors
                      printf("Current Q value: %f \n", matrix[row_calc][4]);
                      matrix[row_calc][4] = matrix[row_calc][4] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][4]);
                      printf("Updated Q value: %f \n", matrix[row_calc][4]);
                   }
                   else
                   {
                       printf("Error choosing a random move \n");
                   }
               }
               else if(Robby.Current == 1)//Can
               {
                   Robby = pick_up(Robby, l_board);//Performs action
                   Robby = Update_Sensors(Robby, l_board);//Update Sensors
                   printf("Current Q value: %f \n", matrix[row_calc][4]);
                   matrix[row_calc][4] = matrix[row_calc][4] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][4]);
                   printf("Updated Q value: %f \n", matrix[row_calc][4]);
               }
               else if(Robby.North == 1)
               {
                   Robby = move_N(Robby);//Performs action
                   Robby = Update_Sensors(Robby, l_board);//Update Sensors
                   printf("Current Q value: %f \n", matrix[row_calc][0]);
                   matrix[row_calc][0] = matrix[row_calc][0] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0]);
                   printf("Updated Q value: %f \n", matrix[row_calc][0]);
               }
               else if(Robby.South == 1)
               {
                   Robby = move_S(Robby);//Performs action
                   Robby = Update_Sensors(Robby, l_board);//Update Sensors
                   printf("Current Q value: %f \n", matrix[row_calc][1]);
                   matrix[row_calc][1] = matrix[row_calc][1] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1]);
                   printf("Updated Q value: %f \n", matrix[row_calc][1]);
               }
               else if(Robby.West == 1)
               {
                   Robby = move_W(Robby);//Performs action
                   Robby = Update_Sensors(Robby, l_board);//Update Sensors
                   printf("Current Q value: %f \n", matrix[row_calc][2]);
                   matrix[row_calc][2] = matrix[row_calc][2] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][2]);
                   printf("Updated Q value: %f \n", matrix[row_calc][2]);
               }
               else if(Robby.East == 1)
               {
                   Robby = move_E(Robby);//Performs action
                   Robby = Update_Sensors(Robby, l_board);//Update Sensors
                   printf("Current Q value: %f \n", matrix[row_calc][3]);
                   matrix[row_calc][3] = matrix[row_calc][3] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][3]);
                   printf("Updated Q value: %f \n", matrix[row_calc][3]);
               }
               else if(Robby.North == 0)
               {
                   Robby = move_N(Robby);//Performs action
                   Robby = Update_Sensors(Robby, l_board);//Update Sensors
                   printf("Current Q value: %f \n", matrix[row_calc][0]);
                   matrix[row_calc][0] = matrix[row_calc][0] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0]);
                   printf("Updated Q value: %f \n", matrix[row_calc][0]);
               }
               else if(Robby.South == 0)
               {
                   Robby = move_S(Robby);//Performs action
                   Robby = Update_Sensors(Robby, l_board);//Update Sensors
                   printf("Current Q value: %f \n", matrix[row_calc][1]);
                   matrix[row_calc][1] = matrix[row_calc][1] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1]);
                   printf("Updated Q value: %f \n", matrix[row_calc][1]);
               }
               else if(Robby.West == 0)
               {
                   Robby = move_W(Robby);//Performs action
                   Robby = Update_Sensors(Robby, l_board);//Update Sensors
                   printf("Current Q value: %f \n", matrix[row_calc][2]);
                   matrix[row_calc][2] = matrix[row_calc][2] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][2]);
                   printf("Updated Q value: %f \n", matrix[row_calc][2]);
               }
               else if(Robby.East == 0)
               {
                   Robby = move_E(Robby);//Performs action
                   Robby = Update_Sensors(Robby, l_board);//Update Sensors
                   printf("Current Q value: %f \n", matrix[row_calc][3]);
                   matrix[row_calc][3] = matrix[row_calc][3] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][3]);
                   printf("Updated Q value: %f \n", matrix[row_calc][3]);
               }
           }
           else
           {
               printf("Robby decided to act randomly: \n");
               seed = seeder.tv_usec + num + 11;
               srand(seed);
               chosen = rand() % 5;
               if(chosen == 0)//Move N
               {
                    Robby = move_N(Robby);//Performs action
                    Robby = Update_Sensors(Robby, l_board);//Update Sensors
                    printf("Current Q value: %f \n", matrix[row_calc][0]);
                    matrix[row_calc][0] = matrix[row_calc][0] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0]);
                    printf("Updated Q value: %f \n", matrix[row_calc][0]);
               }
               else if (chosen == 1)//Move S
               {
                    Robby = move_S(Robby);//Performs action
                    Robby = Update_Sensors(Robby, l_board);//Update Sensors
                    printf("Current Q value: %f \n", matrix[row_calc][1]);
                    matrix[row_calc][1] = matrix[row_calc][1] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1]);
                    printf("Updated Q value: %f \n", matrix[row_calc][1]);
               }
               else if (chosen == 2)//Move W
               {
                    Robby = move_W(Robby);//Performs action
                    Robby = Update_Sensors(Robby, l_board);//Update Sensors
                    printf("Current Q value: %f \n", matrix[row_calc][2]);
                    matrix[row_calc][2] = matrix[row_calc][2] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][2]);
                    printf("Updated Q value: %f \n", matrix[row_calc][2]);
               }
               else if (chosen == 3)//Move E
               {
                    Robby = move_W(Robby);//Performs action
                    Robby = Update_Sensors(Robby, l_board);//Update Sensors
                    printf("Current Q value: %f \n", matrix[row_calc][3]);
                    matrix[row_calc][0] = matrix[row_calc][3] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][3]);
                    printf("Updated Q value: %f \n", matrix[row_calc][3]);
               }
               else if (chosen == 4)//Pick up can
               {
                   Robby = pick_up(Robby, l_board);//Performs action
                   Robby = Update_Sensors(Robby, l_board);//Update Sensors
                   printf("Current Q value: %f \n", matrix[row_calc][4]);
                   matrix[row_calc][4] = matrix[row_calc][4] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][4]);
                   printf("Updated Q value: %f \n", matrix[row_calc][4]);
               }
               else
               {
                   printf("Error choosing a random move \n");
               }
           }
          M_loop++;
       }
       reward[counter] = Robby.reward;
       counter++;
       printf("Total Reward gained on episode %d: %d \n", N_counter, Robby.reward);
       printf("\n");
       N_counter++;
       N--;
       M_loop = 0;
   }
}

int main ()
{
    //nt N = 5000;
    float Q_Matrix [100][5] = {0};//Q-Matrix for Robby, initialized to 0.
    float reward_plot[50] = {0};
    float test_rewards[5000] = {0};
    float SD[5000] = {0};


    Q_Learning(Q_Matrix, reward_plot);
    print_Q(Q_Matrix);
    Q_Test (Q_Matrix, test_rewards);
    printf("For Training Reward Plot: \n");
    for (int p = 0; 0 < 50; p++)
    {
        printf("Episode %d: %d    ", p+1, reward_plot[p]);
        printf("\n");
    }
    for (int q = 0; 0 < 5000; q++)
    {
        printf("Episode %d: %f    ", q+1, test_rewards[q]);
        printf("\n");
    }
    for (int r = 0; 0 < 5000; r++)
    {
        printf("Episode %d: %f    ", r+1, SD[r]);
        printf("\n");
    }
    return (EXIT_SUCCESS);
}
