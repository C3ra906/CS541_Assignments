//Cera Oh. Fall 2021 CS541 AI.
//Prog3. Q-Learning
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <sys/time.h>
#include <math.h>

typedef struct agent{//Represents agent with five sensors, Current, N, S, E, W. 0 = empty, 1 = can, -1 = wall.
 int Current;
 int North;
 int South;
 int East;
 int West;
 float reward;
 float current_r;
 int row;//Row Robby is in
 int col;//Column Robby is in
}Robot;

Robot move_N(Robot Robby)
{
    if (Robby.North == -1)//Wall
    {
        Robby.reward = Robby.reward - 5;
        Robby.current_r = -5;
        printf("Robby ran into a North wall and bounced back to [%d][%d] \n", Robby.row, Robby.col);
    }
    else if (Robby.North == 0 || Robby.North == 1) //No wall
    {
        Robby.row = Robby.row - 1;
        Robby.current_r = 0;
        printf("Robby moved North to [%d][%d] \n", Robby.row, Robby.col);
    }
    else
    {
        printf("Error moving N :( \n");
    }
    return Robby;
}

Robot move_S(Robot Robby)
{
    if (Robby.South == -1)//Wall
    {
        Robby.reward = Robby.reward -5;
        Robby.current_r = -5;
        printf("Robby ran into a South wall and bounced back to [%d][%d] \n", Robby.row, Robby.col);
    }
    else if (Robby.South == 0 || Robby.South == 1) //No wall
    {
        Robby.row = Robby.row + 1;
        Robby.current_r = 0;
        printf("Robby moved South to [%d][%d] \n", Robby.row, Robby.col);
    }
    else
    {
        printf("Error moving S :( \n");
    }
    return Robby;
}

Robot move_W(Robot Robby)
{
    if (Robby.West == -1)//Wall
    {
        Robby.reward = Robby.reward -5;
        Robby.current_r = -5;
        printf("Robby ran into a West wall and bounced back to [%d][%d] \n", Robby.row, Robby.col);
    }
    else if (Robby.West == 0 || Robby.West == 1) //No wall
    {
        Robby.col = Robby.col - 1;
        Robby.current_r = 0;
        printf("Robby moved West to [%d][%d] \n", Robby.row, Robby.col);
    }
    else
    {
        printf("Error moving W :( \n");
    }
    return Robby;
}

Robot move_E(Robot Robby)
{
    if (Robby.East == -1)//Wall
    {
        Robby.reward = Robby.reward -5;
        Robby.current_r = -5;
        printf("Robby ran into a East wall and bounced back to [%d][%d] \n", Robby.row, Robby.col);
    }
    else if (Robby.East == 0 || Robby.East == 1) //No wall
    {
        Robby.col = Robby.col + 1;
        Robby.current_r = 0;
        printf("Robby moved East to [%d][%d] \n", Robby.row, Robby.col);
    }
    else
    {
        printf("Error moving E :( \n");
    }
    return Robby;
}

Robot pick_up(Robot Robby, int board[10][10])
{
    if (board[Robby.row][Robby.col] == 1)//There's a can
    {
        Robby.reward = Robby.reward + 10;
        Robby.current_r = 10;
        board[Robby.row][Robby.col] = 0;
        printf("Robby picked up a can :) \n");
    }
    else if (board[Robby.row][Robby.col] == 0) //No can
    {
        Robby.reward = Robby.reward - 1;
        Robby.current_r = -1;
        printf("Robby attempted to pick up a can...but there was nothing :( \n");
    }
    else
    {
        printf("Error picking up can :( \n");
    }
    return Robby;
}

int board_ini (int num)
{
    int chosen;//Number generated by rand()
    int seed = 0;
    int size = 2;//Max range of numbers rand() will pick from for can placement.
    struct timeval seeder;

    gettimeofday (&seeder, NULL);
    seed = seeder.tv_usec + num;
    srand(seed);
    chosen = rand() % size;

   return chosen;
}

int* robby_ini (int* position)
{

    int robby_i;//row position for Robby
    int robby_j;//column position for Robby
    int seed = 0;
    int r_size = 10;//Max range of numbers rand() will pick from for Robby's row/col position
    struct timeval seeder;

    gettimeofday (&seeder, NULL);
    seed = seeder.tv_usec;
    srand(seed + 4);

    robby_i = rand() % r_size;

    srand(seed + 15);//seeds rand()
    robby_j = rand() % r_size;

    position[0] = robby_i;
    position[1] = robby_j;

    return position;
}

Robot Update_Sensors (Robot Robby, int board[10][10])//Updates sensors and reward info for Robby
{                                                                      // 1 = can, 0 = empty, -1 = wall
//Update Current
    if (board[Robby.row][Robby.col] == 1)
    {
        Robby.Current = 1;//There is a can at current location
    }
    else if (board[Robby.row][Robby.col] == 0)
    {
        Robby.Current = 0;//No can at current location
    }
//Update North Sensor
    if ((Robby.row - 1) >= 0 && (Robby.row - 1) <= 9)//valid value for N: between 0 and 9
    {
        if (board[Robby.row - 1][Robby.col] == 1)
        {
            Robby.North = 1;//There is a can at N
        }
        else if (board[Robby.row - 1][Robby.col] == 0)
        {
        Robby.North = 0;//No can at N
        }
    }
    else
    {
        Robby.North = -1;//Wall at N
    }
//Update South Sensor
 int South;
    if ((Robby.row + 1) >= 0 && (Robby.row + 1) <= 9)//valid value for S: between 0 and 9
    {
        if (board[Robby.row + 1][Robby.col] == 1)
        {
            Robby.South = 1;//Can at S
        }
        else if (board[Robby.row + 1][Robby.col] == 0)
        {
        Robby.South = 0;//No can at S
        }
    }
    else
    {
        Robby.South = -1;//Wall at S
    }
//Update West Sensor
    if ((Robby.col - 1) >= 0 && (Robby.col - 1) <= 9)//valid value for W: between 0 and 9
    {
        if (board[Robby.row][Robby.col - 1] == 1)
        {
            Robby.West = 1;//Can at W
        }
        else if (board[Robby.row][Robby.col - 1] == 0)
        {
        Robby.West = 0;//No can at W
        }
    }
    else
    {
        Robby.West = -1;//Wall at W
    }
//Update East Sensor
    if ((Robby.col + 1) >= 0 && (Robby.col + 1) <= 9)//valid value for E: between 0 and 9
    {
        if (board[Robby.row][Robby.col + 1] == 1)
        {
            Robby.East = 1;//Can at E
        }
        else if (board[Robby.row][Robby.col + 1] == 0)
        {
        Robby.East = 0;//No can at E
        }
    }
    else
    {
        Robby.East = -1;//Wall at E
    }

    return Robby;
}

void print_board(int board[10][10], Robot Robby)//prints 10x10 board
{
    printf(" -----------------------------------------\n");
    for (int i = 0; i < 10; i++)
    {
        printf("%d|", i);
        for (int j = 0; j < 10; j++)
        {
            if (board[i][j] == 1 && (Robby.row != i || Robby.col != j))
            {
                printf(" c |");//can
            }
            else if (board[i][j] == 1 && (Robby.row == i && Robby.col == j))
            {
                printf(" Rc|");//Robby
            }
            else if (board[i][j] == 0 && (Robby.row == i && Robby.col == j))
            {
                printf(" R |");//Robby
            }
            else
            {
                printf("   |");
            }
        }
        printf("\n");
        printf(" -----------------------------------------\n");
    }
        printf("   0   1   2   3   4   5   6   7   8   9  \n");
}

void print_Q(float matrix[100][2][5])//prints Q_Matrix
{
    int counter = 0;
    int k = 0;
    int l = 0;
    int c = 0;
    int r = 0;
    printf("Printing Q-Matrix: \n");
    printf(" Matrix |Can    |\tNorth    |\tSouth    |\tWest     |\tEast     |\tPick Up   \n");
    printf("---------------------------------------------------------------------------------------------------\n");

    for (int i = 0; i < 200; i++)
    {
        printf(" [%d][%d] |", l, k);
        printf("\t%d |", c);

        for(int j = 0; j < 5; j++)
        {
            printf("\t%f |", matrix[r][c][j]);
        }

        printf("\n");
        printf("---------------------------------------------------------------------------------------------------\n");
        c++;

        if (c == 2)
        {
           k++;
           r++;
           if (k == 10)
           {
               l++;
               k = 0;
           }
           c = 0;
        }
    }
}

void print_Robby(Robot Robby)
{
    printf("Robby's Current Stats: \n");
    printf("Robby is at [%d][%d] \n", Robby.row,Robby.col);
    if (Robby.Current == 1)
    {
        printf("Current: Can \n");
    }
    else if (Robby.Current == 0)
    {
        printf("Current: Empty \n");
    }
    else
    {
        printf("Current Sensor failed :(\n");
    }

    if (Robby.North == 1)
    {
        printf("North: Can \n");
    }
    else if (Robby.North == 0)
    {
        printf("North: Empty \n");
    }
    else if (Robby.North == -1)
    {
        printf("North: Wall \n");
    }
    else
    {
        printf("North Sensor failed :(\n");
    }

    if (Robby.South == 1)
    {
        printf("South: Can \n");
    }
    else if (Robby.South == 0)
    {
        printf("South: Empty \n");
    }
    else if (Robby.South == -1)
    {
        printf("South: Wall \n");
    }
    else
    {
        printf("South Sensor failed :(\n");
    }

    if (Robby.West == 1)
    {
        printf("West: Can \n");
    }
    else if (Robby.West == 0)
    {
        printf("West: Empty \n");
    }
    else if (Robby.West == -1)
    {
        printf("West: Wall \n");
    }
    else
    {
        printf("West Sensor failed :(\n");
    }

    if (Robby.East == 1)
    {
        printf("East: Can \n");
    }
    else if (Robby.East == 0)
    {
        printf("East: Empty \n");
    }
    else if (Robby.East == -1)
    {
        printf("East: Wall \n");
    }
    else
    {
        printf("East Sensor failed :(\n");
    }

    printf("Total Reward: %f \n", Robby.reward);
    printf("\n");
}

void Q_Learning (float matrix[100][2][5], float reward_plot[50])
{
   int N = 5000;//Number of episodes
   int M = 200;//Number of steps
   float alpha = 0.2;//Learning rate
   float gamma = 0.9;//Discount rate
   int epsilon = 10;//0.1 for epsilon greedy action selection

   int l_board [10][10];//Creates 10x10 board world for Robby and cans for learning
   Robot Robby;//Robby created for learning

 //variables for looping and counting
   int counter = 0;
   int N_counter = 1;
   int M_loop = 0;
   int d_epsilon = 1;

 //variables for holding values
   int row_calc;
   int n_row_calc;
   int* position;
   int m = 0;
   float curr_reward = 0.0;
   float max_action = 0.0;
   int max_act_index = 0;
   int currentC;
   int currentN;
   int currentS;
   int currentW;
   int currentE;

 //for rand() generator
   struct timeval seeder;
   int seed = 0;
   int num = 10;
   int can;//Number generated by rand() to determine whether there should be a can on a grid
   int prob;//Probability for rand()
   int chosen;//Number generated by rand() as action to perform

   position = malloc(2*sizeof(int));

   while (N > 0)//Loops N episodes
   {
       printf("Starting Learning episode %d: \n", N_counter);
       for (int i = 0; i < 10; i++)//initializes the board with cans
       {
           for (int j = 0; j < 10; j++)
           {
                can = board_ini(num);
                num++;
                if (can == 1)
                {
                    l_board[i][j] = 1;
                }
                else
                {
                    l_board[i][j] = 0;
                }
            }
        }

        position = robby_ini(position);//initializes Robby by placing him on a random square
        Robby.row = position[0];
        Robby.col = position[1];
        Robby = Update_Sensors(Robby, l_board);//initializes Robby's sensors
        Robby.reward = 0;//initializes reward to 0
        Robby.current_r = 0;//initializes current reward to 0

        if (d_epsilon % 50 == 0 && epsilon != 0)//Lowers epsilon by 0.01 every 50 epoch until epsilon is 0.
        {
            epsilon = epsilon - 1;
        }

        while (M_loop < M)//Loops M steps
        {
            printf("\n");
            printf("Learning Episode %d Step %d: \n", N_counter, M_loop +1);
            //print_board(l_board, Robby);
            //print_Robby(Robby);//Prints current status of Robby
            row_calc = (Robby.row * 10) + Robby.col;//Converts Robby's position to Q-matrix index

            currentC = Robby.Current;
            currentN = Robby.North;
            currentS = Robby.South;
            currentW = Robby.West;
            currentE = Robby.East;

            gettimeofday (&seeder, NULL);
            seed = seeder.tv_usec + 10;
            srand(seed);
            prob = rand() % 100;

            for (int k = 0; k < 5; k++)//Calculate maxQ(s, a)
            {
                 if (k == 0)
                 {
                      if (Robby.North == 0)
                      {
                         m = 0;
                      }
                      else if (Robby.North == 1)
                      {
                         m = 1;
                      }
                      if (matrix[row_calc][m][k] > max_action)
                      {
                         max_action = matrix[row_calc][m][k];
                         max_act_index = k;
                      }
                 }
                 if (k == 1)
                 {
                     if (Robby.South == 0)
                     {
                         m = 0;
                     }
                     else if (Robby.South == 1)
                     {
                         m = 1;
                     }
                     if (matrix[row_calc][m][k] > max_action)
                     {
                         max_action = matrix[row_calc][m][k];
                         max_act_index = k;
                     }
                 }
                 if (k == 2)
                 {
                     if (Robby.West == 0)
                     {
                        m = 0;
                     }
                     else if (Robby.West == 1)
                     {
                         m = 1;
                     }
                     if (matrix[row_calc][m][k] > max_action)
                     {
                         max_action = matrix[row_calc][m][k];
                         max_act_index = k;
                     }
                 }
                 if (k == 3)
                 {
                     if (Robby.East == 0)
                     {
                         m = 0;
                     }
                     else if (Robby.East == 1)
                     {
                        m = 1;
                     }
                     if (matrix[row_calc][m][k] > max_action)
                     {
                         max_action = matrix[row_calc][m][k];
                         max_act_index = k;
                     }
                }
                if (k == 4)
                {
                    if (Robby.Current == 0)
                    {
                       m = 0;
                    }
                    else if (Robby.Current == 1)
                    {
                        m = 1;
                    }
                    if (matrix[row_calc][m][k] > max_action)
                    {
                        max_action = matrix[row_calc][m][k];
                        max_act_index = k;
                    }
                 }
             }

            if (prob < epsilon || max_action == 0.0)//Act random
            {
                 printf("Robby decided to act randomly: \n");
                 gettimeofday (&seeder, NULL);
                 seed = seeder.tv_usec + num + 11;
                 srand(seed);
                 chosen = rand() % 5;
                 printf("chosen was %d. Seed was %d \n", chosen, seed);
                 if(chosen == 0)//Move N
                 {

                     if ((Robby.row - 1) >= 0)
                     {
                         n_row_calc = ((Robby.row - 1) * 10) + Robby.col;//Converts Robby's N position to Q-matrix index

                     }
                     else
                     {
                         n_row_calc = row_calc;
                     }

                     Robby = move_N(Robby);//take action: move North
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors

                     for (int k = 0; k < 5; k++)//Calculate maxQ(s', a')
                     {
                         if (k == 0)
                         {
                             if (Robby.North == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.North == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 1)
                         {
                             if (Robby.South == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.South == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 2)
                         {
                             if (Robby.West == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.West == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 3)
                         {
                             if (Robby.East == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.East == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 4)
                         {
                             if (Robby.Current == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.Current == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                     }

                     if (currentN == 1)//N has a can
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][1][0]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][0], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][0]);
                         matrix[row_calc][1][0] = matrix[row_calc][1][0] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][0]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][1][0]);
                     }
                     else if (currentN == 0)
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][0][0]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][0], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][0]);
                         matrix[row_calc][0][0] = matrix[row_calc][0][0] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][0]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][0][0]);
                     }
                     else if (currentN == -1)
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][0][0]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][0], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][0]);
                         matrix[row_calc][0][0] = matrix[row_calc][0][0] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][0]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][0][0]);
                         //printf("Current Q value: %f \n", matrix[row_calc][1][0]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][0], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][0]);
                         matrix[row_calc][1][0] = matrix[row_calc][1][0] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][0]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][1][0]);
                     }
                     else
                     {
                         printf("Error moving Robby N \n");
                     }
                  }
                else if (chosen == 1)//Move S
                {
                     if ((Robby.row + 1) < 10)
                     {
                         n_row_calc = ((Robby.row + 1) * 10) + Robby.col;//Converts Robby's S position to Q-matrix index
                     }
                     else
                     {
                         n_row_calc = row_calc;
                     }

                     Robby = move_S(Robby);//Performs action: Move S
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors

                     for (int k = 0; k < 5; k++)//Calculate maxQ(s', a')
                     {
                         if (k == 0)
                         {
                             if (Robby.North == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.North == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 1)
                         {
                             if (Robby.South == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.South == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 2)
                         {
                             if (Robby.West == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.West == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 3)
                         {
                             if (Robby.East == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.East == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 4)
                         {
                             if (Robby.Current == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.Current == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                     }

                     if (currentS == 1)//N has a can
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][1][1]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][1], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][1]);
                         matrix[row_calc][1][1] = matrix[row_calc][1][1] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][1]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][1][1]);
                     }
                     else if (currentS == 0)
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][0][1]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][1], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][1]);
                         matrix[row_calc][0][1] = matrix[row_calc][0][1] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][1]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][0][1]);
                     }
                     else if (currentS == -1)
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][0][1]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][1], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][1]);
                         matrix[row_calc][0][1] = matrix[row_calc][0][1] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][1]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][0][1]);
                         //printf("Current Q value: %f \n", matrix[row_calc][1][1]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][1], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][1]);
                         matrix[row_calc][1][1] = matrix[row_calc][1][1] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][1]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][1][1]);
                     }
                     else
                     {
                         printf("Error moving Robby S \n");
                     }
               }
               else if (chosen == 2)//Move W
               {
                     if ((Robby.col - 1) >= 0)
                     {
                         n_row_calc = (Robby.row * 10) + Robby.col - 1;//Converts Robby's W position to Q-matrix index
                     }
                     else
                     {
                         n_row_calc = row_calc;
                     }

                     Robby = move_W(Robby);//Performs action
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors

                     for (int k = 0; k < 5; k++)//Calculate maxQ(s', a')
                     {
                         if (k == 0)
                         {
                             if (Robby.North == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.North == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 1)
                         {
                             if (Robby.South == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.South == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 2)
                         {
                             if (Robby.West == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.West == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 3)
                         {
                             if (Robby.East == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.East == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 4)
                         {
                             if (Robby.Current == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.Current == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                     }

                     if (currentW == 1)//W has a can
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][1][2]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][2], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][2]);
                         matrix[row_calc][1][2] = matrix[row_calc][1][2] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][2]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][1][2]);
                     }
                     else if (currentW == 0)//W has no can
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][0][2]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][2], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][2]);
                         matrix[row_calc][0][2] = matrix[row_calc][0][2] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][2]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][0][2]);
                     }
                     else if (currentW == -1)//W has a wall
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][0][2]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][2], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][2]);
                         matrix[row_calc][0][2] = matrix[row_calc][0][2] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][2]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][0][2]);
                         //printf("Current Q value: %f \n", matrix[row_calc][1][2]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][2], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][2]);
                         matrix[row_calc][1][2] = matrix[row_calc][1][2] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][2]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][1][2]);
                     }
                     else
                     {
                         printf("Error moving Robby W \n");
                     }
               }
               else if (chosen == 3)//Move E
               {
                     if ((Robby.col + 1) < 10)
                     {
                         n_row_calc = (Robby.row * 10) + Robby.col + 1;//Converts Robby's E position to Q-matrix index
                     }
                     else
                     {
                         n_row_calc = row_calc;
                     }

                     Robby = move_E(Robby);//Performs action
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors

                     for (int k = 0; k < 5; k++)//Calculate maxQ(s', a')
                     {
                         if (k == 0)
                         {
                             if (Robby.North == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.North == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 1)
                         {
                             if (Robby.South == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.South == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 2)
                         {
                             if (Robby.West == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.West == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 3)
                         {
                             if (Robby.East == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.East == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 4)
                         {
                             if (Robby.Current == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.Current == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                     }

                     if (currentE == 1)//E has a can
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][1][3]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][3], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][3]);
                         matrix[row_calc][1][3] = matrix[row_calc][1][3] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][3]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][1][3]);
                     }
                     else if (currentE == 0)//E doesn't have a can
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][0][3]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][3], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][3]);
                         matrix[row_calc][0][3] = matrix[row_calc][0][3] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][3]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][0][3]);
                     }
                     else if (currentE == -1)//E has a wall
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][0][3]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][3], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][3]);
                         matrix[row_calc][0][3] = matrix[row_calc][0][3] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][3]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][0][3]);
                         //printf("Current Q value: %f \n", matrix[row_calc][1][3]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][3], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][3]);
                         matrix[row_calc][1][3] = matrix[row_calc][1][3] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][3]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][1][3]);
                     }
                     else
                     {
                         printf("Error moving Robby E \n");
                     }
               }
               else if (chosen == 4)//Pick up can
               {
                     Robby = pick_up(Robby, l_board);//Performs action
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors
                     row_calc = (Robby.row * 10) + Robby.col;//Converts Robby's N position to Q-matrix index

                     for (int k = 0; k < 5; k++)//Calculate maxQ(s', a')
                     {
                         if (k == 0)
                         {
                             if (Robby.North == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.North == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 1)
                         {
                             if (Robby.South == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.South == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 2)
                         {
                             if (Robby.West == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.West == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 3)
                         {
                             if (Robby.East == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.East == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 4)
                         {
                             if (Robby.Current == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.Current == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                     }

                     if (currentC == 1)
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][1][4]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][4], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][4]);
                         matrix[row_calc][1][4] = matrix[row_calc][1][4] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][4]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][1][4]);
                     }
                     else if (currentC == 0)
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][0][4]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][4], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][4]);
                         matrix[row_calc][0][4] = matrix[row_calc][0][4] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][4]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][0][4]);
                     }
                     else if (currentC == -1)
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][0][4]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][4], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][4]);
                         matrix[row_calc][0][4] = matrix[row_calc][0][4] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][4]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][0][4]);
                         //printf("Current Q value: %f \n", matrix[row_calc][1][4]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][4], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][4]);
                         matrix[row_calc][1][4] = matrix[row_calc][1][4] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][4]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][1][4]);
                     }
                     else
                     {
                         printf("Error Picking Up \n");
                     }
               }
               else
               {
                   printf("Error choosing a random move \n");
               }

            }
            else //do the max action
            {
                 if(max_act_index == 0)//Move N
                 {
                     if (Robby.row - 1 >= 0)
                     {
                         n_row_calc = ((Robby.row - 1) * 10) + Robby.col;//Converts Robby's N position to Q-matrix index
                     }
                     else
                     {
                         n_row_calc = row_calc;
                     }

                     Robby = move_N(Robby);
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors

                     for (int k = 0; k < 5; k++)//Calculate maxQ(s', a')
                     {
                         if (k == 0)
                         {
                             if (Robby.North == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.North == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 1)
                         {
                             if (Robby.South == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.South == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 2)
                         {
                             if (Robby.West == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.West == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 3)
                         {
                             if (Robby.East == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.East == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 4)
                         {
                             if (Robby.Current == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.Current == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                     }

                     if (currentN == 1)//N has a can
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][1][0]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][0], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][0]);
                         matrix[row_calc][1][0] = matrix[row_calc][1][0] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][0]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][1][0]);
                     }
                     else if (currentN == 0)
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][0][0]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][0], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][0]);
                         matrix[row_calc][0][0] = matrix[row_calc][0][0] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][0]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][0][0]);
                     }
                     else if (currentN == -1)
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][0][0]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][0], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][0]);
                         matrix[row_calc][0][0] = matrix[row_calc][0][0] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][0]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][0][0]);
                         //printf("Current Q value: %f \n", matrix[row_calc][1][0]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][0], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][0]);
                         matrix[row_calc][1][0] = matrix[row_calc][1][0] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][0]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][1][0]);
                     }
                     else
                     {
                         printf("Error moving Robby N \n");
                     }
                  }
                else if (max_act_index == 1)//Move S
                {

                     if (Robby.row + 1 < 10)
                     {
                         n_row_calc = ((Robby.row + 1) * 10) + Robby.col;//Converts Robby's S position to Q-matrix index
                     }
                     else
                     {
                         n_row_calc = row_calc;
                     }

                     Robby = move_S(Robby);//Performs action
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors

                     for (int k = 0; k < 5; k++)//Calculate maxQ(s', a')
                     {
                         if (k == 0)
                         {
                             if (Robby.North == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.North == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 1)
                         {
                             if (Robby.South == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.South == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 2)
                         {
                             if (Robby.West == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.West == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 3)
                         {
                             if (Robby.East == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.East == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 4)
                         {
                             if (Robby.Current == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.Current == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                     }

                     if (currentS == 1)//N has a can
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][1][1]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][1], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][1]);
                         matrix[row_calc][1][1] = matrix[row_calc][1][1] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][1]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][1][1]);
                     }
                     else if (currentS == 0)
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][0][1]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][1], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][1]);
                         matrix[row_calc][0][1] = matrix[row_calc][0][1] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][1]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][0][1]);
                     }
                     else if (currentS == -1)
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][0][1]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][1], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][1]);
                         matrix[row_calc][0][1] = matrix[row_calc][0][1] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][1]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][0][1]);
                         //printf("Current Q value: %f \n", matrix[row_calc][1][1]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][1], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][1]);
                         matrix[row_calc][1][1] = matrix[row_calc][1][1] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][1]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][1][1]);
                     }
                     else
                     {
                         printf("Error moving Robby S \n");
                     }
               }
               else if (max_act_index == 2)//Move W
               {

                     if (Robby.col - 1 >= 0)
                     {
                         n_row_calc = (Robby.row * 10) + Robby.col - 1;//Converts Robby's W position to Q-matrix index
                     }
                     else
                     {
                         n_row_calc = row_calc;
                     }

                     Robby = move_W(Robby);//Performs action
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors

                     for (int k = 0; k < 5; k++)//Calculate maxQ(s', a')
                     {
                         if (k == 0)
                         {
                             if (Robby.North == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.North == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 1)
                         {
                             if (Robby.South == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.South == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 2)
                         {
                             if (Robby.West == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.West == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 3)
                         {
                             if (Robby.East == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.East == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 4)
                         {
                             if (Robby.Current == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.Current == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                     }

                     if (currentW == 1)//W has a can
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][1][2]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][2], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][2]);
                         matrix[row_calc][1][2] = matrix[row_calc][1][2] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][2]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][1][2]);
                     }
                     else if (currentW == 0)
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][0][2]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][2], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][2]);
                         matrix[row_calc][0][2] = matrix[row_calc][0][2] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][2]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][0][2]);
                     }
                     else if (currentW == -1)
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][0][2]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][2], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][2]);
                         matrix[row_calc][0][2] = matrix[row_calc][0][2] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][2]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][0][2]);
                         //printf("Current Q value: %f \n", matrix[row_calc][1][2]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][2], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][2]);
                         matrix[row_calc][1][2] = matrix[row_calc][1][2] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][2]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][1][2]);
                     }
                     else
                     {
                         printf("Error moving Robby W \n");
                     }
               }
               else if (max_act_index == 3)//Move E
               {
                     if (Robby.col + 1 >= 0)
                     {
                         n_row_calc = (Robby.row * 10) + Robby.col + 1;//Converts Robby's E position to Q-matrix index
                     }
                     else
                     {
                         n_row_calc = row_calc;
                     }

                     Robby = move_E(Robby);//Performs action
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors

                     for (int k = 0; k < 5; k++)//Calculate maxQ(s', a')
                     {
                         if (k == 0)
                         {
                             if (Robby.North == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.North == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 1)
                         {
                             if (Robby.South == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.South == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 2)
                         {
                             if (Robby.West == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.West == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 3)
                         {
                             if (Robby.East == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.East == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 4)
                         {
                             if (Robby.Current == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.Current == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                     }

                     if (currentE == 1)//N has a can
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][1][3]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][3], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][3]);
                         matrix[row_calc][1][3] = matrix[row_calc][1][3] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][3]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][1][3]);
                     }
                     else if (currentE == 0)
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][0][3]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][3], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][3]);
                         matrix[row_calc][0][3] = matrix[row_calc][0][3] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][3]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][0][3]);
                     }
                     else if (currentE == -1)
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][0][3]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][3], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][3]);
                         matrix[row_calc][0][3] = matrix[row_calc][0][3] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][3]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][0][3]);
                         //printf("Current Q value: %f \n", matrix[row_calc][1][3]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][3], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][3]);
                         matrix[row_calc][1][3] = matrix[row_calc][1][3] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][3]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][1][3]);
                     }
                     else
                     {
                         printf("Error moving Robby E \n");
                     }
               }
               else if (max_act_index == 4)//Pick up can
               {
                     Robby = pick_up(Robby, l_board);//Performs action
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors
                     row_calc = (Robby.row * 10) + Robby.col;//Converts Robby's N position to Q-matrix index
                     for (int k = 0; k < 5; k++)//Calculate maxQ(s', a')
                     {
                         if (k == 0)
                         {
                             if (Robby.North == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.North == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 1)
                         {
                             if (Robby.South == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.South == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 2)
                         {
                             if (Robby.West == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.West == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 3)
                         {
                             if (Robby.East == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.East == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 4)
                         {
                             if (Robby.Current == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.Current == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                     }

                     if (currentC == 1)
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][1][4]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][4], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][4]);
                         matrix[row_calc][1][4] = matrix[row_calc][1][4] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][4]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][1][4]);
                     }
                     else if (currentC == 0)
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][0][4]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][4], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][4]);
                         matrix[row_calc][0][4] = matrix[row_calc][0][4] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][4]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][0][4]);
                     }
                     else if (currentC == -1)
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][0][4]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][4], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][4]);
                         matrix[row_calc][0][4] = matrix[row_calc][0][4] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][4]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][0][4]);
                         //printf("Current Q value: %f \n", matrix[row_calc][1][4]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][4], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][4]);
                         matrix[row_calc][1][4] = matrix[row_calc][1][4] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][4]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][1][4]);
                     }
                     else
                     {
                         printf("Error Picking Up \n");
                     }
                }
                else
                {
                    printf("Unknown error trying to perform max action \n");
                }
            }
            M_loop++;
            max_action = 0.0;
            num = num + 3;
        }

        if (N_counter % 100 == 0)
        {
            reward_plot[counter] = Robby.reward;
            counter++;
        }

        printf("Total Reward gained on episode %d: %f \n", N_counter, Robby.reward);
        printf("\n");
        M_loop = 0;
        N_counter++;
        N--;
        d_epsilon++;
    }
}

float Standard_Dev (float t_r[5000], float SD[5000])
{
    float avg = 0.0;
    float calc = 0.0;

    for (int i = 0; i < 5000; i++)
    {
        avg = avg + t_r[i];
    }
    avg = avg/5000;

    for (int j = 0; j < 5000; j++)
    {
        calc = t_r[j] - avg;
        SD[j] = powf(calc, 2);
    }

    return avg;
}

void TestAverge_TestSD(float t_r[5000], float SD[5000])
{
    float avg = 0.0;
    float calc = 0.0;
    float total_sd = 0.0;
    float avg_sd = 0.0;

    for (int i = 0; i < 5000; i++)
    {
        avg = avg + t_r[i];
    }
    avg = avg/5000;

    printf("Test-Average was %f \n", avg);

    for (int j = 0; j < 5000; j++)
    {
        calc = t_r[j] - avg;
        SD[j] = powf(calc, 2);
        total_sd = total_sd + SD[j];
    }

    avg_sd = total_sd/5000;

    printf("Test_Standard Deviation was %f \n", avg_sd);
}


void Q_Test (float matrix[100][2][5], float reward[200])
{
   int N = 5000;//Number of episodes
   int M = 200;//Number of steps
   float alpha = 0.2;//Learning rate
   float gamma = 0.9;//Discount rate
   int epsilon = 10;//0.1 for epsilon greedy action selection

   int l_board [10][10];//Creates 10x10 board world for Robby and cans for learning
   Robot Robby;//Robby created for learning

 //variables for looping and counting
   int counter = 0;
   int N_counter = 1;
   int M_loop = 0;
   int d_epsilon = 1;

 //variables for holding values
   int row_calc;
   int n_row_calc;
   int* position;
   int m = 0;
   float curr_reward = 0.0;
   float max_action = 0.0;
   int max_act_index = 0;
   int currentC;
   int currentN;
   int currentS;
   int currentW;
   int currentE;

 //for rand() generator
   struct timeval seeder;
   int seed = 0;
   int num = 10;
   int can;//Number generated by rand() to determine whether there should be a can on a grid
   int prob;//Probability for rand()
   int chosen;//Number generated by rand() as action to perform

   position = malloc(2*sizeof(int));

   while (N > 0)//Loops N episodes
   {
       printf("Starting Test episode %d: \n", N_counter);
       for (int i = 0; i < 10; i++)//initializes the board with cans
       {
           for (int j = 0; j < 10; j++)
           {
                can = board_ini(num);
                num++;
                if (can == 1)
                {
                    l_board[i][j] = 1;
                }
                else
                {
                    l_board[i][j] = 0;
                }
            }
        }

        position = robby_ini(position);//initializes Robby by placing him on a random square
        Robby.row = position[0];
        Robby.col = position[1];
        Robby = Update_Sensors(Robby, l_board);//initializes Robby's sensors
        Robby.reward = 0;//initializes reward to 0
        Robby.current_r = 0;//initializes current reward to 0

        while (M_loop < M)//Loops M steps
        {
            printf("\n");
            printf("Test Episode %d Step %d: \n", N_counter, M_loop +1);
            //print_board(l_board, Robby);
            //print_Robby(Robby);//Prints current status of Robby
            row_calc = (Robby.row * 10) + Robby.col;//Converts Robby's position to Q-matrix index

            currentC = Robby.Current;
            currentN = Robby.North;
            currentS = Robby.South;
            currentW = Robby.West;
            currentE = Robby.East;

            gettimeofday (&seeder, NULL);
            seed = seeder.tv_usec + 10;
            srand(seed);
            prob = rand() % 100;

            for (int k = 0; k < 5; k++)//Calculate maxQ(s, a)
            {
                 if (k == 0)
                 {
                      if (Robby.North == 0)
                      {
                         m = 0;
                      }
                      else if (Robby.North == 1)
                      {
                         m = 1;
                      }
                      if (matrix[row_calc][m][k] > max_action)
                      {
                         max_action = matrix[row_calc][m][k];
                         max_act_index = k;
                      }
                 }
                 if (k == 1)
                 {
                     if (Robby.South == 0)
                     {
                         m = 0;
                     }
                     else if (Robby.South == 1)
                     {
                         m = 1;
                     }
                     if (matrix[row_calc][m][k] > max_action)
                     {
                         max_action = matrix[row_calc][m][k];
                         max_act_index = k;
                     }
                 }
                 if (k == 2)
                 {
                     if (Robby.West == 0)
                     {
                        m = 0;
                     }
                     else if (Robby.West == 1)
                     {
                         m = 1;
                     }
                     if (matrix[row_calc][m][k] > max_action)
                     {
                         max_action = matrix[row_calc][m][k];
                         max_act_index = k;
                     }
                 }
                 if (k == 3)
                 {
                     if (Robby.East == 0)
                     {
                         m = 0;
                     }
                     else if (Robby.East == 1)
                     {
                        m = 1;
                     }
                     if (matrix[row_calc][m][k] > max_action)
                     {
                         max_action = matrix[row_calc][m][k];
                         max_act_index = k;
                     }
                }
                if (k == 4)
                {
                    if (Robby.Current == 0)
                    {
                       m = 0;
                    }
                    else if (Robby.Current == 1)
                    {
                        m = 1;
                    }
                    if (matrix[row_calc][m][k] > max_action)
                    {
                        max_action = matrix[row_calc][m][k];
                        max_act_index = k;
                    }
                 }
             }

            if (prob < epsilon || max_action == 0.0)//Act random
            {
                 printf("Robby decided to act randomly: \n");
                 seed = seeder.tv_usec + num + 11;
                 srand(seed);
                 chosen = rand() % 5;
                 if(chosen == 0)//Move N
                 {
                     if ((Robby.row - 1) >= 0)
                     {
                         n_row_calc = ((Robby.row - 1) * 10) + Robby.col;//Converts Robby's N position to Q-matrix index

                     }
                     else
                     {
                         n_row_calc = row_calc;
                     }

                     Robby = move_N(Robby);//take action: move North
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors

                     for (int k = 0; k < 5; k++)//Calculate maxQ(s', a')
                     {
                         if (k == 0)
                         {
                             if (Robby.North == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.North == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 1)
                         {
                             if (Robby.South == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.South == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 2)
                         {
                             if (Robby.West == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.West == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 3)
                         {
                             if (Robby.East == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.East == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 4)
                         {
                             if (Robby.Current == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.Current == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                     }

                     if (currentN == 1)//N has a can
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][1][0]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][0], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][0]);
                         matrix[row_calc][1][0] = matrix[row_calc][1][0] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][0]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][1][0]);
                     }
                     else if (currentN == 0)//N no can
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][0][0]);
                        // printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][0], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][0]);
                         matrix[row_calc][0][0] = matrix[row_calc][0][0] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][0]);
                        // printf("Updated Q value: %f \n", matrix[row_calc][0][0]);
                     }
                     else if (currentN == -1)//N wall
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][0][0]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][0], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][0]);
                         matrix[row_calc][0][0] = matrix[row_calc][0][0] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][0]);
                        // printf("Updated Q value: %f \n", matrix[row_calc][0][0]);
                        // printf("Current Q value: %f \n", matrix[row_calc][1][0]);
                        // printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][0], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][0]);
                         matrix[row_calc][1][0] = matrix[row_calc][1][0] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][0]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][1][0]);
                     }
                     else
                     {
                         printf("Error moving Robby N \n");
                     }
                  }
                else if (chosen == 1)//Move S
                {
                     if ((Robby.row + 1) < 10)
                     {
                         n_row_calc = ((Robby.row + 1) * 10) + Robby.col;//Converts Robby's S position to Q-matrix index
                     }
                     else
                     {
                         n_row_calc = row_calc;
                     }

                     Robby = move_S(Robby);//Performs action
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors

                     for (int k = 0; k < 5; k++)//Calculate maxQ(s', a')
                     {
                         if (k == 0)
                         {
                             if (Robby.North == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.North == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 1)
                         {
                             if (Robby.South == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.South == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 2)
                         {
                             if (Robby.West == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.West == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 3)
                         {
                             if (Robby.East == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.East == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 4)
                         {
                             if (Robby.Current == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.Current == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                     }

                     if (currentS == 1)//S has a can
                     {
                        // printf("Current Q value: %f \n", matrix[row_calc][1][1]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][1], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][1]);
                         matrix[row_calc][1][1] = matrix[row_calc][1][1] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][1]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][1][1]);
                     }
                     else if (currentS == 0)//S no can
                     {
                        // printf("Current Q value: %f \n", matrix[row_calc][0][1]);
                        // printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][1], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][1]);
                         matrix[row_calc][0][1] = matrix[row_calc][0][1] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][1]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][0][1]);
                     }
                     else if (currentS == -1)//S wall
                     {
                        // printf("Current Q value: %f \n", matrix[row_calc][0][1]);
                        // printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][1], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][1]);
                         matrix[row_calc][0][1] = matrix[row_calc][0][1] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][1]);
                        // printf("Updated Q value: %f \n", matrix[row_calc][0][1]);
                         //printf("Current Q value: %f \n", matrix[row_calc][1][1]);
                        // printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][1], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][1]);
                         matrix[row_calc][1][1] = matrix[row_calc][1][1] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][1]);
                        //printf("Updated Q value: %f \n", matrix[row_calc][1][1]);
                     }
                     else
                     {
                         printf("Error moving Robby S \n");
                     }
               }
               else if (chosen == 2)//Move W
               {
                     if ((Robby.col - 1) >= 0)
                     {
                         n_row_calc = (Robby.row * 10) + Robby.col - 1;//Converts Robby's W position to Q-matrix index
                     }
                     else
                     {
                         n_row_calc = row_calc;
                     }

                     Robby = move_W(Robby);//Performs action
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors

                     for (int k = 0; k < 5; k++)//Calculate maxQ(s', a')
                     {
                         if (k == 0)
                         {
                             if (Robby.North == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.North == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 1)
                         {
                             if (Robby.South == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.South == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 2)
                         {
                             if (Robby.West == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.West == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 3)
                         {
                             if (Robby.East == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.East == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 4)
                         {
                             if (Robby.Current == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.Current == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                     }

                     if (currentW == 1)//W has a can
                     {
                        // printf("Current Q value: %f \n", matrix[row_calc][1][2]);
                        // printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][2], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][2]);
                         matrix[row_calc][1][2] = matrix[row_calc][1][2] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][2]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][1][2]);
                     }
                     else if (currentW == 0)//W no can
                     {
                        // printf("Current Q value: %f \n", matrix[row_calc][0][2]);
                        // printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][2], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][2]);
                         matrix[row_calc][0][2] = matrix[row_calc][0][2] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][2]);
                        // printf("Updated Q value: %f \n", matrix[row_calc][0][2]);
                     }
                     else if (currentW == -1)//W wall
                     {
                       //  printf("Current Q value: %f \n", matrix[row_calc][0][2]);
                       //  printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][2], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][2]);
                         matrix[row_calc][0][2] = matrix[row_calc][0][2] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][2]);
                       //  printf("Updated Q value: %f \n", matrix[row_calc][0][2]);
                        // printf("Current Q value: %f \n", matrix[row_calc][1][2]);
                        // printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][2], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][2]);
                         matrix[row_calc][1][2] = matrix[row_calc][1][2] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][2]);
                        // printf("Updated Q value: %f \n", matrix[row_calc][1][2]);
                     }
                     else
                     {
                         printf("Error moving Robby W \n");
                     }
               }
               else if (chosen == 3)//Move E
               {
                     if ((Robby.col + 1) < 10)
                     {
                         n_row_calc = (Robby.row * 10) + Robby.col + 1;//Converts Robby's E position to Q-matrix index
                     }
                     else
                     {
                         n_row_calc = row_calc;
                     }

                     Robby = move_E(Robby);//Performs action
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors

                     for (int k = 0; k < 5; k++)//Calculate maxQ(s', a')
                     {
                         if (k == 0)
                         {
                             if (Robby.North == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.North == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 1)
                         {
                             if (Robby.South == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.South == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 2)
                         {
                             if (Robby.West == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.West == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 3)
                         {
                             if (Robby.East == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.East == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 4)
                         {
                             if (Robby.Current == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.Current == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                     }

                     if (currentE == 1)//E has a can
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][1][3]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][3], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][3]);
                         matrix[row_calc][1][3] = matrix[row_calc][1][3] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][3]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][1][3]);
                     }
                     else if (currentE == 0)//E no can
                     {
                        // printf("Current Q value: %f \n", matrix[row_calc][0][3]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][3], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][3]);
                         matrix[row_calc][0][3] = matrix[row_calc][0][3] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][3]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][0][3]);
                     }
                     else if (currentE == -1)//E wall
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][0][3]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][3], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][3]);
                         matrix[row_calc][0][3] = matrix[row_calc][0][3] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][3]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][0][3]);
                         //printf("Current Q value: %f \n", matrix[row_calc][1][3]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][3], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][3]);
                         matrix[row_calc][1][3] = matrix[row_calc][1][3] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][3]);
                        // printf("Updated Q value: %f \n", matrix[row_calc][1][3]);
                     }
                     else
                     {
                         printf("Error moving Robby E \n");
                     }
               }
               else if (chosen == 4)//Pick up can
               {
                     Robby = pick_up(Robby, l_board);//Performs action
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors
                     row_calc = (Robby.row * 10) + Robby.col;//Converts Robby's N position to Q-matrix index

                     for (int k = 0; k < 5; k++)//Calculate maxQ(s', a')
                     {
                         if (k == 0)
                         {
                             if (Robby.North == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.North == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 1)
                         {
                             if (Robby.South == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.South == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 2)
                         {
                             if (Robby.West == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.West == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 3)
                         {
                             if (Robby.East == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.East == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 4)
                         {
                             if (Robby.Current == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.Current == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                     }

                     if (currentC == 1)
                     {
                        // printf("Current Q value: %f \n", matrix[row_calc][1][4]);
                        // printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][4], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][4]);
                         matrix[row_calc][1][4] = matrix[row_calc][1][4] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][4]);
                        // printf("Updated Q value: %f \n", matrix[row_calc][1][4]);
                     }
                     else if (currentC == 0)
                     {
                        // printf("Current Q value: %f \n", matrix[row_calc][0][4]);
                        // printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][4], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][4]);
                         matrix[row_calc][0][4] = matrix[row_calc][0][4] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][4]);
                        // printf("Updated Q value: %f \n", matrix[row_calc][0][4]);
                     }
                     else if (currentC == -1)
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][0][4]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][4], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][4]);
                         matrix[row_calc][0][4] = matrix[row_calc][0][4] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][4]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][0][4]);
                         //printf("Current Q value: %f \n", matrix[row_calc][1][4]);
                        // printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][4], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][4]);
                         matrix[row_calc][1][4] = matrix[row_calc][1][4] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][4]);
                        // printf("Updated Q value: %f \n", matrix[row_calc][1][4]);
                     }
                     else
                     {
                         printf("Error Picking Up \n");
                     }
               }
               else
               {
                   printf("Error choosing a random move \n");
               }

            }
            else //do the max action
            {
                 if(max_act_index == 0)//Move N
                 {
                     if (Robby.row - 1 >= 0)
                     {
                         n_row_calc = ((Robby.row - 1) * 10) + Robby.col;//Converts Robby's N position to Q-matrix index
                     }
                     else
                     {
                         n_row_calc = row_calc;
                     }

                     Robby = move_N(Robby);//take action
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors

                     for (int k = 0; k < 5; k++)//Calculate maxQ(s', a')
                     {
                         if (k == 0)
                         {
                             if (Robby.North == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.North == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 1)
                         {
                             if (Robby.South == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.South == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 2)
                         {
                             if (Robby.West == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.West == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 3)
                         {
                             if (Robby.East == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.East == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                         if (k == 4)
                         {
                             if (Robby.Current == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.Current == 1)
                             {
                                m = 1;
                             }
                             if (matrix[n_row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[n_row_calc][m][k];
                             }
                         }
                     }

                     if (currentN == 1)//N has a can
                     {
                        // printf("Current Q value: %f \n", matrix[row_calc][1][0]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][0], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][0]);
                         matrix[row_calc][1][0] = matrix[row_calc][1][0] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][0]);
                       //  printf("Updated Q value: %f \n", matrix[row_calc][1][0]);
                     }
                     else if (currentN == 0)//N no can
                     {
                        // printf("Current Q value: %f \n", matrix[row_calc][0][0]);
                        // printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][0], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][0]);
                         matrix[row_calc][0][0] = matrix[row_calc][0][0] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][0]);
                        // printf("Updated Q value: %f \n", matrix[row_calc][0][0]);
                     }
                     else if (currentN == -1)//N wall
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][0][0]);
                        // printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][0], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][0]);
                         matrix[row_calc][0][0] = matrix[row_calc][0][0] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][0]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][0][0]);
                         //printf("Current Q value: %f \n", matrix[row_calc][1][0]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][0], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][0]);
                         matrix[row_calc][1][0] = matrix[row_calc][1][0] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][0]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][1][0]);
                     }
                     else
                     {
                         printf("Error moving Robby N \n");
                     }
                  }
                else if (max_act_index == 1)//Move S
                {
                     if (Robby.row + 1 < 10)
                     {
                         n_row_calc = ((Robby.row + 1) * 10) + Robby.col;//Converts Robby's S position to Q-matrix index
                     }
                     else
                     {
                         n_row_calc = row_calc;
                     }

                     Robby = move_S(Robby);//Performs action
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors

                     for (int k = 0; k < 5; k++)//Calculate maxQ(s', a')
                     {
                         if (k == 0)
                         {
                             if (Robby.North == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.North == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 1)
                         {
                             if (Robby.South == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.South == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 2)
                         {
                             if (Robby.West == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.West == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 3)
                         {
                             if (Robby.East == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.East == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 4)
                         {
                             if (Robby.Current == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.Current == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                     }

                     if (currentS == 1)//S has a can
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][1][1]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][1], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][1]);
                         matrix[row_calc][1][1] = matrix[row_calc][1][1] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][1]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][1][1]);
                     }
                     else if (currentS == 0)//S no can
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][0][1]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][1], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][1]);
                         matrix[row_calc][0][1] = matrix[row_calc][0][1] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][1]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][0][1]);
                     }
                     else if (currentS == -1)//S wall
                     {
                        // printf("Current Q value: %f \n", matrix[row_calc][0][1]);
                        // printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][1], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][1]);
                         matrix[row_calc][0][1] = matrix[row_calc][0][1] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][1]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][0][1]);
                         //printf("Current Q value: %f \n", matrix[row_calc][1][1]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][1], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][1]);
                         matrix[row_calc][1][1] = matrix[row_calc][1][1] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][1]);
                        // printf("Updated Q value: %f \n", matrix[row_calc][1][1]);
                     }
                     else
                     {
                         printf("Error moving Robby S \n");
                     }
               }
               else if (max_act_index == 2)//Move W
               {
                     if (Robby.col - 1 >= 0)
                     {
                         n_row_calc = (Robby.row * 10) + Robby.col - 1;//Converts Robby's W position to Q-matrix index
                     }
                     else
                     {
                         n_row_calc = row_calc;
                     }

                     Robby = move_W(Robby);//Performs action
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors

                     for (int k = 0; k < 5; k++)//Calculate maxQ(s', a')
                     {
                         if (k == 0)
                         {
                             if (Robby.North == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.North == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 1)
                         {
                             if (Robby.South == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.South == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 2)
                         {
                             if (Robby.West == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.West == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 3)
                         {
                             if (Robby.East == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.East == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 4)
                         {
                             if (Robby.Current == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.Current == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                     }

                     if (currentW == 1)//W has a can
                     {
                        // printf("Current Q value: %f \n", matrix[row_calc][1][2]);
                        // printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][2], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][2]);
                         matrix[row_calc][1][2] = matrix[row_calc][1][2] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][2]);
                        // printf("Updated Q value: %f \n", matrix[row_calc][1][2]);
                     }
                     else if (currentW == 0)//W no can
                     {
                        // printf("Current Q value: %f \n", matrix[row_calc][0][2]);
                        // printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][2], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][2]);
                         matrix[row_calc][0][2] = matrix[row_calc][0][2] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][2]);
                        // printf("Updated Q value: %f \n", matrix[row_calc][0][2]);
                     }
                     else if (currentW == -1)//W wall
                     {
                        // printf("Current Q value: %f \n", matrix[row_calc][0][2]);
                        // printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][2], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][2]);
                         matrix[row_calc][0][2] = matrix[row_calc][0][2] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][2]);
                        // printf("Updated Q value: %f \n", matrix[row_calc][0][2]);
                        // printf("Current Q value: %f \n", matrix[row_calc][1][2]);
                        // printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][2], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][2]);
                         matrix[row_calc][1][2] = matrix[row_calc][1][2] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][2]);
                        // printf("Updated Q value: %f \n", matrix[row_calc][1][2]);
                     }
                     else
                     {
                         printf("Error moving Robby W \n");
                     }
               }
               else if (max_act_index == 3)//Move E
               {
                     if (Robby.col + 1 >= 0)
                     {
                         n_row_calc = (Robby.row * 10) + Robby.col + 1;//Converts Robby's E position to Q-matrix index
                     }
                     else
                     {
                         n_row_calc = row_calc;
                     }

                     Robby = move_E(Robby);//Performs action
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors

                     for (int k = 0; k < 5; k++)//Calculate maxQ(s', a')
                     {
                         if (k == 0)
                         {
                             if (Robby.North == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.North == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 1)
                         {
                             if (Robby.South == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.South == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 2)
                         {
                             if (Robby.West == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.West == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 3)
                         {
                             if (Robby.East == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.East == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 4)
                         {
                             if (Robby.Current == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.Current == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                     }

                     if (currentE == 1)//E has a can
                     {
                        // printf("Current Q value: %f \n", matrix[row_calc][1][3]);
                        // printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][3], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][3]);
                         matrix[row_calc][1][3] = matrix[row_calc][1][3] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][3]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][1][3]);
                     }
                     else if (currentE == 0)//E no can
                     {
                        // printf("Current Q value: %f \n", matrix[row_calc][0][3]);
                        // printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][3], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][3]);
                         matrix[row_calc][0][3] = matrix[row_calc][0][3] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][3]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][0][3]);
                     }
                     else if (currentE == -1)//E wall
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][0][3]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][3], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][3]);
                         matrix[row_calc][0][3] = matrix[row_calc][0][3] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][3]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][0][3]);
                        // printf("Current Q value: %f \n", matrix[row_calc][1][3]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][3], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][3]);
                         matrix[row_calc][1][3] = matrix[row_calc][1][3] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][3]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][1][3]);
                     }
                     else
                     {
                         printf("Error moving Robby E \n");
                     }
               }
               else if (max_act_index == 4)//Pick up can
               {
                     Robby = pick_up(Robby, l_board);//Performs action
                     Robby = Update_Sensors(Robby, l_board);//Update Sensors
                     row_calc = (Robby.row * 10) + Robby.col;//Converts Robby's N position to Q-matrix index

                     for (int k = 0; k < 5; k++)//Calculate maxQ(s', a')
                     {
                         if (k == 0)
                         {
                             if (Robby.North == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.North == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 1)
                         {
                             if (Robby.South == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.South == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 2)
                         {
                             if (Robby.West == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.West == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 3)
                         {
                             if (Robby.East == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.East == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                         if (k == 4)
                         {
                             if (Robby.Current == 0)
                             {
                                m = 0;
                             }
                             else if (Robby.Current == 1)
                             {
                                m = 1;
                             }
                             if (matrix[row_calc][m][k] > max_action)
                             {
                                 max_action = matrix[row_calc][m][k];
                             }
                         }
                     }

                     if (currentC == 1)
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][1][4]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][4], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][4]);
                         matrix[row_calc][1][4] = matrix[row_calc][1][4] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][4]);
                        // printf("Updated Q value: %f \n", matrix[row_calc][1][4]);
                     }
                     else if (currentC == 0)
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][0][4]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][4], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][4]);
                         matrix[row_calc][0][4] = matrix[row_calc][0][4] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][4]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][0][4]);
                     }
                     else if (currentC == -1)
                     {
                         //printf("Current Q value: %f \n", matrix[row_calc][0][4]);
                        // printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][0][4], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][0][4]);
                         matrix[row_calc][0][4] = matrix[row_calc][0][4] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][0][4]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][0][4]);
                        // printf("Current Q value: %f \n", matrix[row_calc][1][4]);
                         //printf("Math: %f + %f * (%f + %f * %f - %f )\n", matrix[row_calc][1][4], alpha, Robby.current_r, gamma, max_action, matrix[row_calc][1][4]);
                         matrix[row_calc][1][4] = matrix[row_calc][1][4] + alpha*(Robby.current_r + gamma*max_action - matrix[row_calc][1][4]);
                         //printf("Updated Q value: %f \n", matrix[row_calc][1][4]);
                     }
                     else
                     {
                         printf("Error Picking Up \n");
                     }
                }
                else
                {
                    printf("Unknown error trying to perform max action \n");
                }
            }
            M_loop++;
            max_action = 0.0;
        }

        reward[counter] = Robby.reward;
        counter++;

        printf("Total Reward gained on episode %d: %f \n", N_counter, Robby.reward);
        printf("\n");
        M_loop = 0;
        N_counter++;
        N--;
    }
}

int main ()
{
    float Q_Matrix [100][2][5] = {0.0};//Q-Matrix for Robby, initialized to 0.
    float reward_plot[50] = {0.0};
    float test_rewards[5000] = {0.0};
    float SD[5000] = {0.0};

    Q_Learning(Q_Matrix, reward_plot);
    print_Q(Q_Matrix);
    Q_Test (Q_Matrix, test_rewards);
    printf("For Training Reward Plot: \n");
    for (int p = 0; p < 50; p++)
    {
        printf("Episode %d: %d    ", p+1, reward_plot[p]);
        printf("\n");
    }

    printf("For Test Rewards: \n");
    printf("Episode   |\tTest Reward  |\tSD          \n");
    printf("------------------------------\n");
    for (int q = 0; q < 5000; q++)
    {
        printf("%d        |\t%f    |\t%f     ", q+1, test_rewards[q], SD[q]);
        printf("\n");
    }

    TestAverge_TestSD(test_rewards, SD);

    return (EXIT_SUCCESS);
}
